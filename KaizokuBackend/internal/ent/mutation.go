// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/technobecet/kaizoku-go/internal/ent/downloadqueueitem"
	"github.com/technobecet/kaizoku-go/internal/ent/etagcache"
	"github.com/technobecet/kaizoku-go/internal/ent/importentry"
	"github.com/technobecet/kaizoku-go/internal/ent/latestseries"
	"github.com/technobecet/kaizoku-go/internal/ent/predicate"
	"github.com/technobecet/kaizoku-go/internal/ent/providerstorage"
	"github.com/technobecet/kaizoku-go/internal/ent/series"
	"github.com/technobecet/kaizoku-go/internal/ent/seriesprovider"
	"github.com/technobecet/kaizoku-go/internal/ent/setting"
	"github.com/technobecet/kaizoku-go/internal/ent/sourceevent"
	"github.com/technobecet/kaizoku-go/internal/types"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDownloadQueueItem = "DownloadQueueItem"
	TypeEtagCache         = "EtagCache"
	TypeImportEntry       = "ImportEntry"
	TypeLatestSeries      = "LatestSeries"
	TypeProviderStorage   = "ProviderStorage"
	TypeSeries            = "Series"
	TypeSeriesProvider    = "SeriesProvider"
	TypeSetting           = "Setting"
	TypeSourceEvent       = "SourceEvent"
)

// DownloadQueueItemMutation represents an operation that mutates the DownloadQueueItem nodes in the graph.
type DownloadQueueItemMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	group_key     *string
	status        *int
	addstatus     *int
	priority      *int
	addpriority   *int
	scheduled_at  *time.Time
	created_at    *time.Time
	started_at    *time.Time
	completed_at  *time.Time
	args          *types.DownloadChapterArgs
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DownloadQueueItem, error)
	predicates    []predicate.DownloadQueueItem
}

var _ ent.Mutation = (*DownloadQueueItemMutation)(nil)

// downloadqueueitemOption allows management of the mutation configuration using functional options.
type downloadqueueitemOption func(*DownloadQueueItemMutation)

// newDownloadQueueItemMutation creates new mutation for the DownloadQueueItem entity.
func newDownloadQueueItemMutation(c config, op Op, opts ...downloadqueueitemOption) *DownloadQueueItemMutation {
	m := &DownloadQueueItemMutation{
		config:        c,
		op:            op,
		typ:           TypeDownloadQueueItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDownloadQueueItemID sets the ID field of the mutation.
func withDownloadQueueItemID(id uuid.UUID) downloadqueueitemOption {
	return func(m *DownloadQueueItemMutation) {
		var (
			err   error
			once  sync.Once
			value *DownloadQueueItem
		)
		m.oldValue = func(ctx context.Context) (*DownloadQueueItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DownloadQueueItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDownloadQueueItem sets the old DownloadQueueItem of the mutation.
func withDownloadQueueItem(node *DownloadQueueItem) downloadqueueitemOption {
	return func(m *DownloadQueueItemMutation) {
		m.oldValue = func(context.Context) (*DownloadQueueItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DownloadQueueItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DownloadQueueItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DownloadQueueItem entities.
func (m *DownloadQueueItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DownloadQueueItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DownloadQueueItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DownloadQueueItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupKey sets the "group_key" field.
func (m *DownloadQueueItemMutation) SetGroupKey(s string) {
	m.group_key = &s
}

// GroupKey returns the value of the "group_key" field in the mutation.
func (m *DownloadQueueItemMutation) GroupKey() (r string, exists bool) {
	v := m.group_key
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupKey returns the old "group_key" field's value of the DownloadQueueItem entity.
// If the DownloadQueueItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadQueueItemMutation) OldGroupKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupKey: %w", err)
	}
	return oldValue.GroupKey, nil
}

// ResetGroupKey resets all changes to the "group_key" field.
func (m *DownloadQueueItemMutation) ResetGroupKey() {
	m.group_key = nil
}

// SetStatus sets the "status" field.
func (m *DownloadQueueItemMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DownloadQueueItemMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DownloadQueueItem entity.
// If the DownloadQueueItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadQueueItemMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DownloadQueueItemMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DownloadQueueItemMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *DownloadQueueItemMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPriority sets the "priority" field.
func (m *DownloadQueueItemMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *DownloadQueueItemMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the DownloadQueueItem entity.
// If the DownloadQueueItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadQueueItemMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *DownloadQueueItemMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *DownloadQueueItemMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *DownloadQueueItemMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetScheduledAt sets the "scheduled_at" field.
func (m *DownloadQueueItemMutation) SetScheduledAt(t time.Time) {
	m.scheduled_at = &t
}

// ScheduledAt returns the value of the "scheduled_at" field in the mutation.
func (m *DownloadQueueItemMutation) ScheduledAt() (r time.Time, exists bool) {
	v := m.scheduled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAt returns the old "scheduled_at" field's value of the DownloadQueueItem entity.
// If the DownloadQueueItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadQueueItemMutation) OldScheduledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAt: %w", err)
	}
	return oldValue.ScheduledAt, nil
}

// ResetScheduledAt resets all changes to the "scheduled_at" field.
func (m *DownloadQueueItemMutation) ResetScheduledAt() {
	m.scheduled_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DownloadQueueItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DownloadQueueItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DownloadQueueItem entity.
// If the DownloadQueueItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadQueueItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DownloadQueueItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStartedAt sets the "started_at" field.
func (m *DownloadQueueItemMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *DownloadQueueItemMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the DownloadQueueItem entity.
// If the DownloadQueueItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadQueueItemMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *DownloadQueueItemMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[downloadqueueitem.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *DownloadQueueItemMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[downloadqueueitem.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *DownloadQueueItemMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, downloadqueueitem.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *DownloadQueueItemMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *DownloadQueueItemMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the DownloadQueueItem entity.
// If the DownloadQueueItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadQueueItemMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *DownloadQueueItemMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[downloadqueueitem.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *DownloadQueueItemMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[downloadqueueitem.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *DownloadQueueItemMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, downloadqueueitem.FieldCompletedAt)
}

// SetArgs sets the "args" field.
func (m *DownloadQueueItemMutation) SetArgs(tca types.DownloadChapterArgs) {
	m.args = &tca
}

// Args returns the value of the "args" field in the mutation.
func (m *DownloadQueueItemMutation) Args() (r types.DownloadChapterArgs, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the DownloadQueueItem entity.
// If the DownloadQueueItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadQueueItemMutation) OldArgs(ctx context.Context) (v types.DownloadChapterArgs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *DownloadQueueItemMutation) ResetArgs() {
	m.args = nil
}

// Where appends a list predicates to the DownloadQueueItemMutation builder.
func (m *DownloadQueueItemMutation) Where(ps ...predicate.DownloadQueueItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DownloadQueueItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DownloadQueueItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DownloadQueueItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DownloadQueueItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DownloadQueueItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DownloadQueueItem).
func (m *DownloadQueueItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DownloadQueueItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.group_key != nil {
		fields = append(fields, downloadqueueitem.FieldGroupKey)
	}
	if m.status != nil {
		fields = append(fields, downloadqueueitem.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, downloadqueueitem.FieldPriority)
	}
	if m.scheduled_at != nil {
		fields = append(fields, downloadqueueitem.FieldScheduledAt)
	}
	if m.created_at != nil {
		fields = append(fields, downloadqueueitem.FieldCreatedAt)
	}
	if m.started_at != nil {
		fields = append(fields, downloadqueueitem.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, downloadqueueitem.FieldCompletedAt)
	}
	if m.args != nil {
		fields = append(fields, downloadqueueitem.FieldArgs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DownloadQueueItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case downloadqueueitem.FieldGroupKey:
		return m.GroupKey()
	case downloadqueueitem.FieldStatus:
		return m.Status()
	case downloadqueueitem.FieldPriority:
		return m.Priority()
	case downloadqueueitem.FieldScheduledAt:
		return m.ScheduledAt()
	case downloadqueueitem.FieldCreatedAt:
		return m.CreatedAt()
	case downloadqueueitem.FieldStartedAt:
		return m.StartedAt()
	case downloadqueueitem.FieldCompletedAt:
		return m.CompletedAt()
	case downloadqueueitem.FieldArgs:
		return m.Args()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DownloadQueueItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case downloadqueueitem.FieldGroupKey:
		return m.OldGroupKey(ctx)
	case downloadqueueitem.FieldStatus:
		return m.OldStatus(ctx)
	case downloadqueueitem.FieldPriority:
		return m.OldPriority(ctx)
	case downloadqueueitem.FieldScheduledAt:
		return m.OldScheduledAt(ctx)
	case downloadqueueitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case downloadqueueitem.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case downloadqueueitem.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case downloadqueueitem.FieldArgs:
		return m.OldArgs(ctx)
	}
	return nil, fmt.Errorf("unknown DownloadQueueItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadQueueItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case downloadqueueitem.FieldGroupKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupKey(v)
		return nil
	case downloadqueueitem.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case downloadqueueitem.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case downloadqueueitem.FieldScheduledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAt(v)
		return nil
	case downloadqueueitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case downloadqueueitem.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case downloadqueueitem.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case downloadqueueitem.FieldArgs:
		v, ok := value.(types.DownloadChapterArgs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadQueueItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DownloadQueueItemMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, downloadqueueitem.FieldStatus)
	}
	if m.addpriority != nil {
		fields = append(fields, downloadqueueitem.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DownloadQueueItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case downloadqueueitem.FieldStatus:
		return m.AddedStatus()
	case downloadqueueitem.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadQueueItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case downloadqueueitem.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case downloadqueueitem.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadQueueItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DownloadQueueItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(downloadqueueitem.FieldStartedAt) {
		fields = append(fields, downloadqueueitem.FieldStartedAt)
	}
	if m.FieldCleared(downloadqueueitem.FieldCompletedAt) {
		fields = append(fields, downloadqueueitem.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DownloadQueueItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DownloadQueueItemMutation) ClearField(name string) error {
	switch name {
	case downloadqueueitem.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case downloadqueueitem.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown DownloadQueueItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DownloadQueueItemMutation) ResetField(name string) error {
	switch name {
	case downloadqueueitem.FieldGroupKey:
		m.ResetGroupKey()
		return nil
	case downloadqueueitem.FieldStatus:
		m.ResetStatus()
		return nil
	case downloadqueueitem.FieldPriority:
		m.ResetPriority()
		return nil
	case downloadqueueitem.FieldScheduledAt:
		m.ResetScheduledAt()
		return nil
	case downloadqueueitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case downloadqueueitem.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case downloadqueueitem.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case downloadqueueitem.FieldArgs:
		m.ResetArgs()
		return nil
	}
	return fmt.Errorf("unknown DownloadQueueItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DownloadQueueItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DownloadQueueItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DownloadQueueItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DownloadQueueItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DownloadQueueItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DownloadQueueItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DownloadQueueItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DownloadQueueItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DownloadQueueItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DownloadQueueItem edge %s", name)
}

// EtagCacheMutation represents an operation that mutates the EtagCache nodes in the graph.
type EtagCacheMutation struct {
	config
	op            Op
	typ           string
	id            *string
	etag          *string
	last_updated  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EtagCache, error)
	predicates    []predicate.EtagCache
}

var _ ent.Mutation = (*EtagCacheMutation)(nil)

// etagcacheOption allows management of the mutation configuration using functional options.
type etagcacheOption func(*EtagCacheMutation)

// newEtagCacheMutation creates new mutation for the EtagCache entity.
func newEtagCacheMutation(c config, op Op, opts ...etagcacheOption) *EtagCacheMutation {
	m := &EtagCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeEtagCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEtagCacheID sets the ID field of the mutation.
func withEtagCacheID(id string) etagcacheOption {
	return func(m *EtagCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *EtagCache
		)
		m.oldValue = func(ctx context.Context) (*EtagCache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EtagCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEtagCache sets the old EtagCache of the mutation.
func withEtagCache(node *EtagCache) etagcacheOption {
	return func(m *EtagCacheMutation) {
		m.oldValue = func(context.Context) (*EtagCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EtagCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EtagCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EtagCache entities.
func (m *EtagCacheMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EtagCacheMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EtagCacheMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EtagCache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEtag sets the "etag" field.
func (m *EtagCacheMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *EtagCacheMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the EtagCache entity.
// If the EtagCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EtagCacheMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *EtagCacheMutation) ResetEtag() {
	m.etag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *EtagCacheMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *EtagCacheMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the EtagCache entity.
// If the EtagCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EtagCacheMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *EtagCacheMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// Where appends a list predicates to the EtagCacheMutation builder.
func (m *EtagCacheMutation) Where(ps ...predicate.EtagCache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EtagCacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EtagCacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EtagCache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EtagCacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EtagCacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EtagCache).
func (m *EtagCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EtagCacheMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.etag != nil {
		fields = append(fields, etagcache.FieldEtag)
	}
	if m.last_updated != nil {
		fields = append(fields, etagcache.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EtagCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case etagcache.FieldEtag:
		return m.Etag()
	case etagcache.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EtagCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case etagcache.FieldEtag:
		return m.OldEtag(ctx)
	case etagcache.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown EtagCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EtagCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case etagcache.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case etagcache.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown EtagCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EtagCacheMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EtagCacheMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EtagCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EtagCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EtagCacheMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EtagCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EtagCacheMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EtagCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EtagCacheMutation) ResetField(name string) error {
	switch name {
	case etagcache.FieldEtag:
		m.ResetEtag()
		return nil
	case etagcache.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown EtagCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EtagCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EtagCacheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EtagCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EtagCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EtagCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EtagCacheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EtagCacheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EtagCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EtagCacheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EtagCache edge %s", name)
}

// ImportEntryMutation represents an operation that mutates the ImportEntry nodes in the graph.
type ImportEntryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	title                     *string
	status                    *int
	addstatus                 *int
	action                    *int
	addaction                 *int
	info                      **types.KaizokuInfo
	series                    *[]map[string]interface{}
	appendseries              []map[string]interface{}
	continue_after_chapter    *float64
	addcontinue_after_chapter *float64
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*ImportEntry, error)
	predicates                []predicate.ImportEntry
}

var _ ent.Mutation = (*ImportEntryMutation)(nil)

// importentryOption allows management of the mutation configuration using functional options.
type importentryOption func(*ImportEntryMutation)

// newImportEntryMutation creates new mutation for the ImportEntry entity.
func newImportEntryMutation(c config, op Op, opts ...importentryOption) *ImportEntryMutation {
	m := &ImportEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeImportEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImportEntryID sets the ID field of the mutation.
func withImportEntryID(id string) importentryOption {
	return func(m *ImportEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *ImportEntry
		)
		m.oldValue = func(ctx context.Context) (*ImportEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImportEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImportEntry sets the old ImportEntry of the mutation.
func withImportEntry(node *ImportEntry) importentryOption {
	return func(m *ImportEntryMutation) {
		m.oldValue = func(context.Context) (*ImportEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImportEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImportEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ImportEntry entities.
func (m *ImportEntryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImportEntryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImportEntryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImportEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ImportEntryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ImportEntryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ImportEntry entity.
// If the ImportEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportEntryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ImportEntryMutation) ResetTitle() {
	m.title = nil
}

// SetStatus sets the "status" field.
func (m *ImportEntryMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ImportEntryMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ImportEntry entity.
// If the ImportEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportEntryMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ImportEntryMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ImportEntryMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ImportEntryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAction sets the "action" field.
func (m *ImportEntryMutation) SetAction(i int) {
	m.action = &i
	m.addaction = nil
}

// Action returns the value of the "action" field in the mutation.
func (m *ImportEntryMutation) Action() (r int, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the ImportEntry entity.
// If the ImportEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportEntryMutation) OldAction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// AddAction adds i to the "action" field.
func (m *ImportEntryMutation) AddAction(i int) {
	if m.addaction != nil {
		*m.addaction += i
	} else {
		m.addaction = &i
	}
}

// AddedAction returns the value that was added to the "action" field in this mutation.
func (m *ImportEntryMutation) AddedAction() (r int, exists bool) {
	v := m.addaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetAction resets all changes to the "action" field.
func (m *ImportEntryMutation) ResetAction() {
	m.action = nil
	m.addaction = nil
}

// SetInfo sets the "info" field.
func (m *ImportEntryMutation) SetInfo(ti *types.KaizokuInfo) {
	m.info = &ti
}

// Info returns the value of the "info" field in the mutation.
func (m *ImportEntryMutation) Info() (r *types.KaizokuInfo, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the ImportEntry entity.
// If the ImportEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportEntryMutation) OldInfo(ctx context.Context) (v *types.KaizokuInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ClearInfo clears the value of the "info" field.
func (m *ImportEntryMutation) ClearInfo() {
	m.info = nil
	m.clearedFields[importentry.FieldInfo] = struct{}{}
}

// InfoCleared returns if the "info" field was cleared in this mutation.
func (m *ImportEntryMutation) InfoCleared() bool {
	_, ok := m.clearedFields[importentry.FieldInfo]
	return ok
}

// ResetInfo resets all changes to the "info" field.
func (m *ImportEntryMutation) ResetInfo() {
	m.info = nil
	delete(m.clearedFields, importentry.FieldInfo)
}

// SetSeries sets the "series" field.
func (m *ImportEntryMutation) SetSeries(value []map[string]interface{}) {
	m.series = &value
	m.appendseries = nil
}

// Series returns the value of the "series" field in the mutation.
func (m *ImportEntryMutation) Series() (r []map[string]interface{}, exists bool) {
	v := m.series
	if v == nil {
		return
	}
	return *v, true
}

// OldSeries returns the old "series" field's value of the ImportEntry entity.
// If the ImportEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportEntryMutation) OldSeries(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeries: %w", err)
	}
	return oldValue.Series, nil
}

// AppendSeries adds value to the "series" field.
func (m *ImportEntryMutation) AppendSeries(value []map[string]interface{}) {
	m.appendseries = append(m.appendseries, value...)
}

// AppendedSeries returns the list of values that were appended to the "series" field in this mutation.
func (m *ImportEntryMutation) AppendedSeries() ([]map[string]interface{}, bool) {
	if len(m.appendseries) == 0 {
		return nil, false
	}
	return m.appendseries, true
}

// ClearSeries clears the value of the "series" field.
func (m *ImportEntryMutation) ClearSeries() {
	m.series = nil
	m.appendseries = nil
	m.clearedFields[importentry.FieldSeries] = struct{}{}
}

// SeriesCleared returns if the "series" field was cleared in this mutation.
func (m *ImportEntryMutation) SeriesCleared() bool {
	_, ok := m.clearedFields[importentry.FieldSeries]
	return ok
}

// ResetSeries resets all changes to the "series" field.
func (m *ImportEntryMutation) ResetSeries() {
	m.series = nil
	m.appendseries = nil
	delete(m.clearedFields, importentry.FieldSeries)
}

// SetContinueAfterChapter sets the "continue_after_chapter" field.
func (m *ImportEntryMutation) SetContinueAfterChapter(f float64) {
	m.continue_after_chapter = &f
	m.addcontinue_after_chapter = nil
}

// ContinueAfterChapter returns the value of the "continue_after_chapter" field in the mutation.
func (m *ImportEntryMutation) ContinueAfterChapter() (r float64, exists bool) {
	v := m.continue_after_chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldContinueAfterChapter returns the old "continue_after_chapter" field's value of the ImportEntry entity.
// If the ImportEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportEntryMutation) OldContinueAfterChapter(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinueAfterChapter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinueAfterChapter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinueAfterChapter: %w", err)
	}
	return oldValue.ContinueAfterChapter, nil
}

// AddContinueAfterChapter adds f to the "continue_after_chapter" field.
func (m *ImportEntryMutation) AddContinueAfterChapter(f float64) {
	if m.addcontinue_after_chapter != nil {
		*m.addcontinue_after_chapter += f
	} else {
		m.addcontinue_after_chapter = &f
	}
}

// AddedContinueAfterChapter returns the value that was added to the "continue_after_chapter" field in this mutation.
func (m *ImportEntryMutation) AddedContinueAfterChapter() (r float64, exists bool) {
	v := m.addcontinue_after_chapter
	if v == nil {
		return
	}
	return *v, true
}

// ClearContinueAfterChapter clears the value of the "continue_after_chapter" field.
func (m *ImportEntryMutation) ClearContinueAfterChapter() {
	m.continue_after_chapter = nil
	m.addcontinue_after_chapter = nil
	m.clearedFields[importentry.FieldContinueAfterChapter] = struct{}{}
}

// ContinueAfterChapterCleared returns if the "continue_after_chapter" field was cleared in this mutation.
func (m *ImportEntryMutation) ContinueAfterChapterCleared() bool {
	_, ok := m.clearedFields[importentry.FieldContinueAfterChapter]
	return ok
}

// ResetContinueAfterChapter resets all changes to the "continue_after_chapter" field.
func (m *ImportEntryMutation) ResetContinueAfterChapter() {
	m.continue_after_chapter = nil
	m.addcontinue_after_chapter = nil
	delete(m.clearedFields, importentry.FieldContinueAfterChapter)
}

// Where appends a list predicates to the ImportEntryMutation builder.
func (m *ImportEntryMutation) Where(ps ...predicate.ImportEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImportEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImportEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImportEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImportEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImportEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImportEntry).
func (m *ImportEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImportEntryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, importentry.FieldTitle)
	}
	if m.status != nil {
		fields = append(fields, importentry.FieldStatus)
	}
	if m.action != nil {
		fields = append(fields, importentry.FieldAction)
	}
	if m.info != nil {
		fields = append(fields, importentry.FieldInfo)
	}
	if m.series != nil {
		fields = append(fields, importentry.FieldSeries)
	}
	if m.continue_after_chapter != nil {
		fields = append(fields, importentry.FieldContinueAfterChapter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImportEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case importentry.FieldTitle:
		return m.Title()
	case importentry.FieldStatus:
		return m.Status()
	case importentry.FieldAction:
		return m.Action()
	case importentry.FieldInfo:
		return m.Info()
	case importentry.FieldSeries:
		return m.Series()
	case importentry.FieldContinueAfterChapter:
		return m.ContinueAfterChapter()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImportEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case importentry.FieldTitle:
		return m.OldTitle(ctx)
	case importentry.FieldStatus:
		return m.OldStatus(ctx)
	case importentry.FieldAction:
		return m.OldAction(ctx)
	case importentry.FieldInfo:
		return m.OldInfo(ctx)
	case importentry.FieldSeries:
		return m.OldSeries(ctx)
	case importentry.FieldContinueAfterChapter:
		return m.OldContinueAfterChapter(ctx)
	}
	return nil, fmt.Errorf("unknown ImportEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImportEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case importentry.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case importentry.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case importentry.FieldAction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case importentry.FieldInfo:
		v, ok := value.(*types.KaizokuInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case importentry.FieldSeries:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeries(v)
		return nil
	case importentry.FieldContinueAfterChapter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinueAfterChapter(v)
		return nil
	}
	return fmt.Errorf("unknown ImportEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImportEntryMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, importentry.FieldStatus)
	}
	if m.addaction != nil {
		fields = append(fields, importentry.FieldAction)
	}
	if m.addcontinue_after_chapter != nil {
		fields = append(fields, importentry.FieldContinueAfterChapter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImportEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case importentry.FieldStatus:
		return m.AddedStatus()
	case importentry.FieldAction:
		return m.AddedAction()
	case importentry.FieldContinueAfterChapter:
		return m.AddedContinueAfterChapter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImportEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case importentry.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case importentry.FieldAction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAction(v)
		return nil
	case importentry.FieldContinueAfterChapter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContinueAfterChapter(v)
		return nil
	}
	return fmt.Errorf("unknown ImportEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImportEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(importentry.FieldInfo) {
		fields = append(fields, importentry.FieldInfo)
	}
	if m.FieldCleared(importentry.FieldSeries) {
		fields = append(fields, importentry.FieldSeries)
	}
	if m.FieldCleared(importentry.FieldContinueAfterChapter) {
		fields = append(fields, importentry.FieldContinueAfterChapter)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImportEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImportEntryMutation) ClearField(name string) error {
	switch name {
	case importentry.FieldInfo:
		m.ClearInfo()
		return nil
	case importentry.FieldSeries:
		m.ClearSeries()
		return nil
	case importentry.FieldContinueAfterChapter:
		m.ClearContinueAfterChapter()
		return nil
	}
	return fmt.Errorf("unknown ImportEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImportEntryMutation) ResetField(name string) error {
	switch name {
	case importentry.FieldTitle:
		m.ResetTitle()
		return nil
	case importentry.FieldStatus:
		m.ResetStatus()
		return nil
	case importentry.FieldAction:
		m.ResetAction()
		return nil
	case importentry.FieldInfo:
		m.ResetInfo()
		return nil
	case importentry.FieldSeries:
		m.ResetSeries()
		return nil
	case importentry.FieldContinueAfterChapter:
		m.ResetContinueAfterChapter()
		return nil
	}
	return fmt.Errorf("unknown ImportEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImportEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImportEntryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImportEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImportEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImportEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImportEntryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImportEntryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ImportEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImportEntryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ImportEntry edge %s", name)
}

// LatestSeriesMutation represents an operation that mutates the LatestSeries nodes in the graph.
type LatestSeriesMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	suwayomi_source_id   *string
	provider             *string
	language             *string
	url                  *string
	title                *string
	thumbnail_url        *string
	artist               *string
	author               *string
	description          *string
	genre                *[]string
	appendgenre          []string
	fetch_date           *time.Time
	chapter_count        *int64
	addchapter_count     *int64
	latest_chapter       *float64
	addlatest_chapter    *float64
	latest_chapter_title *string
	status               *string
	in_library           *int
	addin_library        *int
	chapters             *[]types.SuwayomiChapter
	appendchapters       []types.SuwayomiChapter
	clearedFields        map[string]struct{}
	series               *uuid.UUID
	clearedseries        bool
	done                 bool
	oldValue             func(context.Context) (*LatestSeries, error)
	predicates           []predicate.LatestSeries
}

var _ ent.Mutation = (*LatestSeriesMutation)(nil)

// latestseriesOption allows management of the mutation configuration using functional options.
type latestseriesOption func(*LatestSeriesMutation)

// newLatestSeriesMutation creates new mutation for the LatestSeries entity.
func newLatestSeriesMutation(c config, op Op, opts ...latestseriesOption) *LatestSeriesMutation {
	m := &LatestSeriesMutation{
		config:        c,
		op:            op,
		typ:           TypeLatestSeries,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLatestSeriesID sets the ID field of the mutation.
func withLatestSeriesID(id int) latestseriesOption {
	return func(m *LatestSeriesMutation) {
		var (
			err   error
			once  sync.Once
			value *LatestSeries
		)
		m.oldValue = func(ctx context.Context) (*LatestSeries, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LatestSeries.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLatestSeries sets the old LatestSeries of the mutation.
func withLatestSeries(node *LatestSeries) latestseriesOption {
	return func(m *LatestSeriesMutation) {
		m.oldValue = func(context.Context) (*LatestSeries, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LatestSeriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LatestSeriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LatestSeries entities.
func (m *LatestSeriesMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LatestSeriesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LatestSeriesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LatestSeries.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSuwayomiSourceID sets the "suwayomi_source_id" field.
func (m *LatestSeriesMutation) SetSuwayomiSourceID(s string) {
	m.suwayomi_source_id = &s
}

// SuwayomiSourceID returns the value of the "suwayomi_source_id" field in the mutation.
func (m *LatestSeriesMutation) SuwayomiSourceID() (r string, exists bool) {
	v := m.suwayomi_source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSuwayomiSourceID returns the old "suwayomi_source_id" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldSuwayomiSourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuwayomiSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuwayomiSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuwayomiSourceID: %w", err)
	}
	return oldValue.SuwayomiSourceID, nil
}

// ResetSuwayomiSourceID resets all changes to the "suwayomi_source_id" field.
func (m *LatestSeriesMutation) ResetSuwayomiSourceID() {
	m.suwayomi_source_id = nil
}

// SetProvider sets the "provider" field.
func (m *LatestSeriesMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *LatestSeriesMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *LatestSeriesMutation) ResetProvider() {
	m.provider = nil
}

// SetLanguage sets the "language" field.
func (m *LatestSeriesMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *LatestSeriesMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *LatestSeriesMutation) ResetLanguage() {
	m.language = nil
}

// SetURL sets the "url" field.
func (m *LatestSeriesMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *LatestSeriesMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *LatestSeriesMutation) ClearURL() {
	m.url = nil
	m.clearedFields[latestseries.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *LatestSeriesMutation) URLCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *LatestSeriesMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, latestseries.FieldURL)
}

// SetTitle sets the "title" field.
func (m *LatestSeriesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *LatestSeriesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *LatestSeriesMutation) ResetTitle() {
	m.title = nil
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *LatestSeriesMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *LatestSeriesMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldThumbnailURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *LatestSeriesMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[latestseries.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *LatestSeriesMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *LatestSeriesMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, latestseries.FieldThumbnailURL)
}

// SetArtist sets the "artist" field.
func (m *LatestSeriesMutation) SetArtist(s string) {
	m.artist = &s
}

// Artist returns the value of the "artist" field in the mutation.
func (m *LatestSeriesMutation) Artist() (r string, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldArtist(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// ClearArtist clears the value of the "artist" field.
func (m *LatestSeriesMutation) ClearArtist() {
	m.artist = nil
	m.clearedFields[latestseries.FieldArtist] = struct{}{}
}

// ArtistCleared returns if the "artist" field was cleared in this mutation.
func (m *LatestSeriesMutation) ArtistCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldArtist]
	return ok
}

// ResetArtist resets all changes to the "artist" field.
func (m *LatestSeriesMutation) ResetArtist() {
	m.artist = nil
	delete(m.clearedFields, latestseries.FieldArtist)
}

// SetAuthor sets the "author" field.
func (m *LatestSeriesMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *LatestSeriesMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldAuthor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *LatestSeriesMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[latestseries.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *LatestSeriesMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *LatestSeriesMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, latestseries.FieldAuthor)
}

// SetDescription sets the "description" field.
func (m *LatestSeriesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LatestSeriesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LatestSeriesMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[latestseries.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LatestSeriesMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LatestSeriesMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, latestseries.FieldDescription)
}

// SetGenre sets the "genre" field.
func (m *LatestSeriesMutation) SetGenre(s []string) {
	m.genre = &s
	m.appendgenre = nil
}

// Genre returns the value of the "genre" field in the mutation.
func (m *LatestSeriesMutation) Genre() (r []string, exists bool) {
	v := m.genre
	if v == nil {
		return
	}
	return *v, true
}

// OldGenre returns the old "genre" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldGenre(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenre: %w", err)
	}
	return oldValue.Genre, nil
}

// AppendGenre adds s to the "genre" field.
func (m *LatestSeriesMutation) AppendGenre(s []string) {
	m.appendgenre = append(m.appendgenre, s...)
}

// AppendedGenre returns the list of values that were appended to the "genre" field in this mutation.
func (m *LatestSeriesMutation) AppendedGenre() ([]string, bool) {
	if len(m.appendgenre) == 0 {
		return nil, false
	}
	return m.appendgenre, true
}

// ClearGenre clears the value of the "genre" field.
func (m *LatestSeriesMutation) ClearGenre() {
	m.genre = nil
	m.appendgenre = nil
	m.clearedFields[latestseries.FieldGenre] = struct{}{}
}

// GenreCleared returns if the "genre" field was cleared in this mutation.
func (m *LatestSeriesMutation) GenreCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldGenre]
	return ok
}

// ResetGenre resets all changes to the "genre" field.
func (m *LatestSeriesMutation) ResetGenre() {
	m.genre = nil
	m.appendgenre = nil
	delete(m.clearedFields, latestseries.FieldGenre)
}

// SetFetchDate sets the "fetch_date" field.
func (m *LatestSeriesMutation) SetFetchDate(t time.Time) {
	m.fetch_date = &t
}

// FetchDate returns the value of the "fetch_date" field in the mutation.
func (m *LatestSeriesMutation) FetchDate() (r time.Time, exists bool) {
	v := m.fetch_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFetchDate returns the old "fetch_date" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldFetchDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFetchDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFetchDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFetchDate: %w", err)
	}
	return oldValue.FetchDate, nil
}

// ResetFetchDate resets all changes to the "fetch_date" field.
func (m *LatestSeriesMutation) ResetFetchDate() {
	m.fetch_date = nil
}

// SetChapterCount sets the "chapter_count" field.
func (m *LatestSeriesMutation) SetChapterCount(i int64) {
	m.chapter_count = &i
	m.addchapter_count = nil
}

// ChapterCount returns the value of the "chapter_count" field in the mutation.
func (m *LatestSeriesMutation) ChapterCount() (r int64, exists bool) {
	v := m.chapter_count
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterCount returns the old "chapter_count" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldChapterCount(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterCount: %w", err)
	}
	return oldValue.ChapterCount, nil
}

// AddChapterCount adds i to the "chapter_count" field.
func (m *LatestSeriesMutation) AddChapterCount(i int64) {
	if m.addchapter_count != nil {
		*m.addchapter_count += i
	} else {
		m.addchapter_count = &i
	}
}

// AddedChapterCount returns the value that was added to the "chapter_count" field in this mutation.
func (m *LatestSeriesMutation) AddedChapterCount() (r int64, exists bool) {
	v := m.addchapter_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterCount clears the value of the "chapter_count" field.
func (m *LatestSeriesMutation) ClearChapterCount() {
	m.chapter_count = nil
	m.addchapter_count = nil
	m.clearedFields[latestseries.FieldChapterCount] = struct{}{}
}

// ChapterCountCleared returns if the "chapter_count" field was cleared in this mutation.
func (m *LatestSeriesMutation) ChapterCountCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldChapterCount]
	return ok
}

// ResetChapterCount resets all changes to the "chapter_count" field.
func (m *LatestSeriesMutation) ResetChapterCount() {
	m.chapter_count = nil
	m.addchapter_count = nil
	delete(m.clearedFields, latestseries.FieldChapterCount)
}

// SetLatestChapter sets the "latest_chapter" field.
func (m *LatestSeriesMutation) SetLatestChapter(f float64) {
	m.latest_chapter = &f
	m.addlatest_chapter = nil
}

// LatestChapter returns the value of the "latest_chapter" field in the mutation.
func (m *LatestSeriesMutation) LatestChapter() (r float64, exists bool) {
	v := m.latest_chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestChapter returns the old "latest_chapter" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldLatestChapter(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestChapter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestChapter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestChapter: %w", err)
	}
	return oldValue.LatestChapter, nil
}

// AddLatestChapter adds f to the "latest_chapter" field.
func (m *LatestSeriesMutation) AddLatestChapter(f float64) {
	if m.addlatest_chapter != nil {
		*m.addlatest_chapter += f
	} else {
		m.addlatest_chapter = &f
	}
}

// AddedLatestChapter returns the value that was added to the "latest_chapter" field in this mutation.
func (m *LatestSeriesMutation) AddedLatestChapter() (r float64, exists bool) {
	v := m.addlatest_chapter
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatestChapter clears the value of the "latest_chapter" field.
func (m *LatestSeriesMutation) ClearLatestChapter() {
	m.latest_chapter = nil
	m.addlatest_chapter = nil
	m.clearedFields[latestseries.FieldLatestChapter] = struct{}{}
}

// LatestChapterCleared returns if the "latest_chapter" field was cleared in this mutation.
func (m *LatestSeriesMutation) LatestChapterCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldLatestChapter]
	return ok
}

// ResetLatestChapter resets all changes to the "latest_chapter" field.
func (m *LatestSeriesMutation) ResetLatestChapter() {
	m.latest_chapter = nil
	m.addlatest_chapter = nil
	delete(m.clearedFields, latestseries.FieldLatestChapter)
}

// SetLatestChapterTitle sets the "latest_chapter_title" field.
func (m *LatestSeriesMutation) SetLatestChapterTitle(s string) {
	m.latest_chapter_title = &s
}

// LatestChapterTitle returns the value of the "latest_chapter_title" field in the mutation.
func (m *LatestSeriesMutation) LatestChapterTitle() (r string, exists bool) {
	v := m.latest_chapter_title
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestChapterTitle returns the old "latest_chapter_title" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldLatestChapterTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestChapterTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestChapterTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestChapterTitle: %w", err)
	}
	return oldValue.LatestChapterTitle, nil
}

// ResetLatestChapterTitle resets all changes to the "latest_chapter_title" field.
func (m *LatestSeriesMutation) ResetLatestChapterTitle() {
	m.latest_chapter_title = nil
}

// SetStatus sets the "status" field.
func (m *LatestSeriesMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *LatestSeriesMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LatestSeriesMutation) ResetStatus() {
	m.status = nil
}

// SetInLibrary sets the "in_library" field.
func (m *LatestSeriesMutation) SetInLibrary(i int) {
	m.in_library = &i
	m.addin_library = nil
}

// InLibrary returns the value of the "in_library" field in the mutation.
func (m *LatestSeriesMutation) InLibrary() (r int, exists bool) {
	v := m.in_library
	if v == nil {
		return
	}
	return *v, true
}

// OldInLibrary returns the old "in_library" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldInLibrary(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInLibrary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInLibrary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInLibrary: %w", err)
	}
	return oldValue.InLibrary, nil
}

// AddInLibrary adds i to the "in_library" field.
func (m *LatestSeriesMutation) AddInLibrary(i int) {
	if m.addin_library != nil {
		*m.addin_library += i
	} else {
		m.addin_library = &i
	}
}

// AddedInLibrary returns the value that was added to the "in_library" field in this mutation.
func (m *LatestSeriesMutation) AddedInLibrary() (r int, exists bool) {
	v := m.addin_library
	if v == nil {
		return
	}
	return *v, true
}

// ResetInLibrary resets all changes to the "in_library" field.
func (m *LatestSeriesMutation) ResetInLibrary() {
	m.in_library = nil
	m.addin_library = nil
}

// SetSeriesID sets the "series_id" field.
func (m *LatestSeriesMutation) SetSeriesID(u uuid.UUID) {
	m.series = &u
}

// SeriesID returns the value of the "series_id" field in the mutation.
func (m *LatestSeriesMutation) SeriesID() (r uuid.UUID, exists bool) {
	v := m.series
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesID returns the old "series_id" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldSeriesID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesID: %w", err)
	}
	return oldValue.SeriesID, nil
}

// ClearSeriesID clears the value of the "series_id" field.
func (m *LatestSeriesMutation) ClearSeriesID() {
	m.series = nil
	m.clearedFields[latestseries.FieldSeriesID] = struct{}{}
}

// SeriesIDCleared returns if the "series_id" field was cleared in this mutation.
func (m *LatestSeriesMutation) SeriesIDCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldSeriesID]
	return ok
}

// ResetSeriesID resets all changes to the "series_id" field.
func (m *LatestSeriesMutation) ResetSeriesID() {
	m.series = nil
	delete(m.clearedFields, latestseries.FieldSeriesID)
}

// SetChapters sets the "chapters" field.
func (m *LatestSeriesMutation) SetChapters(tc []types.SuwayomiChapter) {
	m.chapters = &tc
	m.appendchapters = nil
}

// Chapters returns the value of the "chapters" field in the mutation.
func (m *LatestSeriesMutation) Chapters() (r []types.SuwayomiChapter, exists bool) {
	v := m.chapters
	if v == nil {
		return
	}
	return *v, true
}

// OldChapters returns the old "chapters" field's value of the LatestSeries entity.
// If the LatestSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LatestSeriesMutation) OldChapters(ctx context.Context) (v []types.SuwayomiChapter, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapters: %w", err)
	}
	return oldValue.Chapters, nil
}

// AppendChapters adds tc to the "chapters" field.
func (m *LatestSeriesMutation) AppendChapters(tc []types.SuwayomiChapter) {
	m.appendchapters = append(m.appendchapters, tc...)
}

// AppendedChapters returns the list of values that were appended to the "chapters" field in this mutation.
func (m *LatestSeriesMutation) AppendedChapters() ([]types.SuwayomiChapter, bool) {
	if len(m.appendchapters) == 0 {
		return nil, false
	}
	return m.appendchapters, true
}

// ClearChapters clears the value of the "chapters" field.
func (m *LatestSeriesMutation) ClearChapters() {
	m.chapters = nil
	m.appendchapters = nil
	m.clearedFields[latestseries.FieldChapters] = struct{}{}
}

// ChaptersCleared returns if the "chapters" field was cleared in this mutation.
func (m *LatestSeriesMutation) ChaptersCleared() bool {
	_, ok := m.clearedFields[latestseries.FieldChapters]
	return ok
}

// ResetChapters resets all changes to the "chapters" field.
func (m *LatestSeriesMutation) ResetChapters() {
	m.chapters = nil
	m.appendchapters = nil
	delete(m.clearedFields, latestseries.FieldChapters)
}

// ClearSeries clears the "series" edge to the Series entity.
func (m *LatestSeriesMutation) ClearSeries() {
	m.clearedseries = true
	m.clearedFields[latestseries.FieldSeriesID] = struct{}{}
}

// SeriesCleared reports if the "series" edge to the Series entity was cleared.
func (m *LatestSeriesMutation) SeriesCleared() bool {
	return m.SeriesIDCleared() || m.clearedseries
}

// SeriesIDs returns the "series" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeriesID instead. It exists only for internal usage by the builders.
func (m *LatestSeriesMutation) SeriesIDs() (ids []uuid.UUID) {
	if id := m.series; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeries resets all changes to the "series" edge.
func (m *LatestSeriesMutation) ResetSeries() {
	m.series = nil
	m.clearedseries = false
}

// Where appends a list predicates to the LatestSeriesMutation builder.
func (m *LatestSeriesMutation) Where(ps ...predicate.LatestSeries) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LatestSeriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LatestSeriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LatestSeries, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LatestSeriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LatestSeriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LatestSeries).
func (m *LatestSeriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LatestSeriesMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.suwayomi_source_id != nil {
		fields = append(fields, latestseries.FieldSuwayomiSourceID)
	}
	if m.provider != nil {
		fields = append(fields, latestseries.FieldProvider)
	}
	if m.language != nil {
		fields = append(fields, latestseries.FieldLanguage)
	}
	if m.url != nil {
		fields = append(fields, latestseries.FieldURL)
	}
	if m.title != nil {
		fields = append(fields, latestseries.FieldTitle)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, latestseries.FieldThumbnailURL)
	}
	if m.artist != nil {
		fields = append(fields, latestseries.FieldArtist)
	}
	if m.author != nil {
		fields = append(fields, latestseries.FieldAuthor)
	}
	if m.description != nil {
		fields = append(fields, latestseries.FieldDescription)
	}
	if m.genre != nil {
		fields = append(fields, latestseries.FieldGenre)
	}
	if m.fetch_date != nil {
		fields = append(fields, latestseries.FieldFetchDate)
	}
	if m.chapter_count != nil {
		fields = append(fields, latestseries.FieldChapterCount)
	}
	if m.latest_chapter != nil {
		fields = append(fields, latestseries.FieldLatestChapter)
	}
	if m.latest_chapter_title != nil {
		fields = append(fields, latestseries.FieldLatestChapterTitle)
	}
	if m.status != nil {
		fields = append(fields, latestseries.FieldStatus)
	}
	if m.in_library != nil {
		fields = append(fields, latestseries.FieldInLibrary)
	}
	if m.series != nil {
		fields = append(fields, latestseries.FieldSeriesID)
	}
	if m.chapters != nil {
		fields = append(fields, latestseries.FieldChapters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LatestSeriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case latestseries.FieldSuwayomiSourceID:
		return m.SuwayomiSourceID()
	case latestseries.FieldProvider:
		return m.Provider()
	case latestseries.FieldLanguage:
		return m.Language()
	case latestseries.FieldURL:
		return m.URL()
	case latestseries.FieldTitle:
		return m.Title()
	case latestseries.FieldThumbnailURL:
		return m.ThumbnailURL()
	case latestseries.FieldArtist:
		return m.Artist()
	case latestseries.FieldAuthor:
		return m.Author()
	case latestseries.FieldDescription:
		return m.Description()
	case latestseries.FieldGenre:
		return m.Genre()
	case latestseries.FieldFetchDate:
		return m.FetchDate()
	case latestseries.FieldChapterCount:
		return m.ChapterCount()
	case latestseries.FieldLatestChapter:
		return m.LatestChapter()
	case latestseries.FieldLatestChapterTitle:
		return m.LatestChapterTitle()
	case latestseries.FieldStatus:
		return m.Status()
	case latestseries.FieldInLibrary:
		return m.InLibrary()
	case latestseries.FieldSeriesID:
		return m.SeriesID()
	case latestseries.FieldChapters:
		return m.Chapters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LatestSeriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case latestseries.FieldSuwayomiSourceID:
		return m.OldSuwayomiSourceID(ctx)
	case latestseries.FieldProvider:
		return m.OldProvider(ctx)
	case latestseries.FieldLanguage:
		return m.OldLanguage(ctx)
	case latestseries.FieldURL:
		return m.OldURL(ctx)
	case latestseries.FieldTitle:
		return m.OldTitle(ctx)
	case latestseries.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case latestseries.FieldArtist:
		return m.OldArtist(ctx)
	case latestseries.FieldAuthor:
		return m.OldAuthor(ctx)
	case latestseries.FieldDescription:
		return m.OldDescription(ctx)
	case latestseries.FieldGenre:
		return m.OldGenre(ctx)
	case latestseries.FieldFetchDate:
		return m.OldFetchDate(ctx)
	case latestseries.FieldChapterCount:
		return m.OldChapterCount(ctx)
	case latestseries.FieldLatestChapter:
		return m.OldLatestChapter(ctx)
	case latestseries.FieldLatestChapterTitle:
		return m.OldLatestChapterTitle(ctx)
	case latestseries.FieldStatus:
		return m.OldStatus(ctx)
	case latestseries.FieldInLibrary:
		return m.OldInLibrary(ctx)
	case latestseries.FieldSeriesID:
		return m.OldSeriesID(ctx)
	case latestseries.FieldChapters:
		return m.OldChapters(ctx)
	}
	return nil, fmt.Errorf("unknown LatestSeries field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LatestSeriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case latestseries.FieldSuwayomiSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuwayomiSourceID(v)
		return nil
	case latestseries.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case latestseries.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case latestseries.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case latestseries.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case latestseries.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case latestseries.FieldArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case latestseries.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case latestseries.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case latestseries.FieldGenre:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenre(v)
		return nil
	case latestseries.FieldFetchDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFetchDate(v)
		return nil
	case latestseries.FieldChapterCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterCount(v)
		return nil
	case latestseries.FieldLatestChapter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestChapter(v)
		return nil
	case latestseries.FieldLatestChapterTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestChapterTitle(v)
		return nil
	case latestseries.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case latestseries.FieldInLibrary:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInLibrary(v)
		return nil
	case latestseries.FieldSeriesID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesID(v)
		return nil
	case latestseries.FieldChapters:
		v, ok := value.([]types.SuwayomiChapter)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapters(v)
		return nil
	}
	return fmt.Errorf("unknown LatestSeries field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LatestSeriesMutation) AddedFields() []string {
	var fields []string
	if m.addchapter_count != nil {
		fields = append(fields, latestseries.FieldChapterCount)
	}
	if m.addlatest_chapter != nil {
		fields = append(fields, latestseries.FieldLatestChapter)
	}
	if m.addin_library != nil {
		fields = append(fields, latestseries.FieldInLibrary)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LatestSeriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case latestseries.FieldChapterCount:
		return m.AddedChapterCount()
	case latestseries.FieldLatestChapter:
		return m.AddedLatestChapter()
	case latestseries.FieldInLibrary:
		return m.AddedInLibrary()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LatestSeriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case latestseries.FieldChapterCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterCount(v)
		return nil
	case latestseries.FieldLatestChapter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatestChapter(v)
		return nil
	case latestseries.FieldInLibrary:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInLibrary(v)
		return nil
	}
	return fmt.Errorf("unknown LatestSeries numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LatestSeriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(latestseries.FieldURL) {
		fields = append(fields, latestseries.FieldURL)
	}
	if m.FieldCleared(latestseries.FieldThumbnailURL) {
		fields = append(fields, latestseries.FieldThumbnailURL)
	}
	if m.FieldCleared(latestseries.FieldArtist) {
		fields = append(fields, latestseries.FieldArtist)
	}
	if m.FieldCleared(latestseries.FieldAuthor) {
		fields = append(fields, latestseries.FieldAuthor)
	}
	if m.FieldCleared(latestseries.FieldDescription) {
		fields = append(fields, latestseries.FieldDescription)
	}
	if m.FieldCleared(latestseries.FieldGenre) {
		fields = append(fields, latestseries.FieldGenre)
	}
	if m.FieldCleared(latestseries.FieldChapterCount) {
		fields = append(fields, latestseries.FieldChapterCount)
	}
	if m.FieldCleared(latestseries.FieldLatestChapter) {
		fields = append(fields, latestseries.FieldLatestChapter)
	}
	if m.FieldCleared(latestseries.FieldSeriesID) {
		fields = append(fields, latestseries.FieldSeriesID)
	}
	if m.FieldCleared(latestseries.FieldChapters) {
		fields = append(fields, latestseries.FieldChapters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LatestSeriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LatestSeriesMutation) ClearField(name string) error {
	switch name {
	case latestseries.FieldURL:
		m.ClearURL()
		return nil
	case latestseries.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case latestseries.FieldArtist:
		m.ClearArtist()
		return nil
	case latestseries.FieldAuthor:
		m.ClearAuthor()
		return nil
	case latestseries.FieldDescription:
		m.ClearDescription()
		return nil
	case latestseries.FieldGenre:
		m.ClearGenre()
		return nil
	case latestseries.FieldChapterCount:
		m.ClearChapterCount()
		return nil
	case latestseries.FieldLatestChapter:
		m.ClearLatestChapter()
		return nil
	case latestseries.FieldSeriesID:
		m.ClearSeriesID()
		return nil
	case latestseries.FieldChapters:
		m.ClearChapters()
		return nil
	}
	return fmt.Errorf("unknown LatestSeries nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LatestSeriesMutation) ResetField(name string) error {
	switch name {
	case latestseries.FieldSuwayomiSourceID:
		m.ResetSuwayomiSourceID()
		return nil
	case latestseries.FieldProvider:
		m.ResetProvider()
		return nil
	case latestseries.FieldLanguage:
		m.ResetLanguage()
		return nil
	case latestseries.FieldURL:
		m.ResetURL()
		return nil
	case latestseries.FieldTitle:
		m.ResetTitle()
		return nil
	case latestseries.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case latestseries.FieldArtist:
		m.ResetArtist()
		return nil
	case latestseries.FieldAuthor:
		m.ResetAuthor()
		return nil
	case latestseries.FieldDescription:
		m.ResetDescription()
		return nil
	case latestseries.FieldGenre:
		m.ResetGenre()
		return nil
	case latestseries.FieldFetchDate:
		m.ResetFetchDate()
		return nil
	case latestseries.FieldChapterCount:
		m.ResetChapterCount()
		return nil
	case latestseries.FieldLatestChapter:
		m.ResetLatestChapter()
		return nil
	case latestseries.FieldLatestChapterTitle:
		m.ResetLatestChapterTitle()
		return nil
	case latestseries.FieldStatus:
		m.ResetStatus()
		return nil
	case latestseries.FieldInLibrary:
		m.ResetInLibrary()
		return nil
	case latestseries.FieldSeriesID:
		m.ResetSeriesID()
		return nil
	case latestseries.FieldChapters:
		m.ResetChapters()
		return nil
	}
	return fmt.Errorf("unknown LatestSeries field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LatestSeriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.series != nil {
		edges = append(edges, latestseries.EdgeSeries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LatestSeriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case latestseries.EdgeSeries:
		if id := m.series; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LatestSeriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LatestSeriesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LatestSeriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedseries {
		edges = append(edges, latestseries.EdgeSeries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LatestSeriesMutation) EdgeCleared(name string) bool {
	switch name {
	case latestseries.EdgeSeries:
		return m.clearedseries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LatestSeriesMutation) ClearEdge(name string) error {
	switch name {
	case latestseries.EdgeSeries:
		m.ClearSeries()
		return nil
	}
	return fmt.Errorf("unknown LatestSeries unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LatestSeriesMutation) ResetEdge(name string) error {
	switch name {
	case latestseries.EdgeSeries:
		m.ResetSeries()
		return nil
	}
	return fmt.Errorf("unknown LatestSeries edge %s", name)
}

// ProviderStorageMutation represents an operation that mutates the ProviderStorage nodes in the graph.
type ProviderStorageMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	apk_name        *string
	pkg_name        *string
	name            *string
	lang            *string
	version_code    *int64
	addversion_code *int64
	is_storage      *bool
	is_disabled     *bool
	mappings        *[]types.ProviderMapping
	appendmappings  []types.ProviderMapping
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ProviderStorage, error)
	predicates      []predicate.ProviderStorage
}

var _ ent.Mutation = (*ProviderStorageMutation)(nil)

// providerstorageOption allows management of the mutation configuration using functional options.
type providerstorageOption func(*ProviderStorageMutation)

// newProviderStorageMutation creates new mutation for the ProviderStorage entity.
func newProviderStorageMutation(c config, op Op, opts ...providerstorageOption) *ProviderStorageMutation {
	m := &ProviderStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeProviderStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderStorageID sets the ID field of the mutation.
func withProviderStorageID(id uuid.UUID) providerstorageOption {
	return func(m *ProviderStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *ProviderStorage
		)
		m.oldValue = func(ctx context.Context) (*ProviderStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProviderStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProviderStorage sets the old ProviderStorage of the mutation.
func withProviderStorage(node *ProviderStorage) providerstorageOption {
	return func(m *ProviderStorageMutation) {
		m.oldValue = func(context.Context) (*ProviderStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProviderStorage entities.
func (m *ProviderStorageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderStorageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderStorageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProviderStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApkName sets the "apk_name" field.
func (m *ProviderStorageMutation) SetApkName(s string) {
	m.apk_name = &s
}

// ApkName returns the value of the "apk_name" field in the mutation.
func (m *ProviderStorageMutation) ApkName() (r string, exists bool) {
	v := m.apk_name
	if v == nil {
		return
	}
	return *v, true
}

// OldApkName returns the old "apk_name" field's value of the ProviderStorage entity.
// If the ProviderStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderStorageMutation) OldApkName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApkName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApkName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApkName: %w", err)
	}
	return oldValue.ApkName, nil
}

// ResetApkName resets all changes to the "apk_name" field.
func (m *ProviderStorageMutation) ResetApkName() {
	m.apk_name = nil
}

// SetPkgName sets the "pkg_name" field.
func (m *ProviderStorageMutation) SetPkgName(s string) {
	m.pkg_name = &s
}

// PkgName returns the value of the "pkg_name" field in the mutation.
func (m *ProviderStorageMutation) PkgName() (r string, exists bool) {
	v := m.pkg_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgName returns the old "pkg_name" field's value of the ProviderStorage entity.
// If the ProviderStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderStorageMutation) OldPkgName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgName: %w", err)
	}
	return oldValue.PkgName, nil
}

// ResetPkgName resets all changes to the "pkg_name" field.
func (m *ProviderStorageMutation) ResetPkgName() {
	m.pkg_name = nil
}

// SetName sets the "name" field.
func (m *ProviderStorageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProviderStorageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProviderStorage entity.
// If the ProviderStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderStorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProviderStorageMutation) ResetName() {
	m.name = nil
}

// SetLang sets the "lang" field.
func (m *ProviderStorageMutation) SetLang(s string) {
	m.lang = &s
}

// Lang returns the value of the "lang" field in the mutation.
func (m *ProviderStorageMutation) Lang() (r string, exists bool) {
	v := m.lang
	if v == nil {
		return
	}
	return *v, true
}

// OldLang returns the old "lang" field's value of the ProviderStorage entity.
// If the ProviderStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderStorageMutation) OldLang(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLang is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLang requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLang: %w", err)
	}
	return oldValue.Lang, nil
}

// ResetLang resets all changes to the "lang" field.
func (m *ProviderStorageMutation) ResetLang() {
	m.lang = nil
}

// SetVersionCode sets the "version_code" field.
func (m *ProviderStorageMutation) SetVersionCode(i int64) {
	m.version_code = &i
	m.addversion_code = nil
}

// VersionCode returns the value of the "version_code" field in the mutation.
func (m *ProviderStorageMutation) VersionCode() (r int64, exists bool) {
	v := m.version_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionCode returns the old "version_code" field's value of the ProviderStorage entity.
// If the ProviderStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderStorageMutation) OldVersionCode(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionCode: %w", err)
	}
	return oldValue.VersionCode, nil
}

// AddVersionCode adds i to the "version_code" field.
func (m *ProviderStorageMutation) AddVersionCode(i int64) {
	if m.addversion_code != nil {
		*m.addversion_code += i
	} else {
		m.addversion_code = &i
	}
}

// AddedVersionCode returns the value that was added to the "version_code" field in this mutation.
func (m *ProviderStorageMutation) AddedVersionCode() (r int64, exists bool) {
	v := m.addversion_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionCode resets all changes to the "version_code" field.
func (m *ProviderStorageMutation) ResetVersionCode() {
	m.version_code = nil
	m.addversion_code = nil
}

// SetIsStorage sets the "is_storage" field.
func (m *ProviderStorageMutation) SetIsStorage(b bool) {
	m.is_storage = &b
}

// IsStorage returns the value of the "is_storage" field in the mutation.
func (m *ProviderStorageMutation) IsStorage() (r bool, exists bool) {
	v := m.is_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldIsStorage returns the old "is_storage" field's value of the ProviderStorage entity.
// If the ProviderStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderStorageMutation) OldIsStorage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsStorage: %w", err)
	}
	return oldValue.IsStorage, nil
}

// ResetIsStorage resets all changes to the "is_storage" field.
func (m *ProviderStorageMutation) ResetIsStorage() {
	m.is_storage = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *ProviderStorageMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *ProviderStorageMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the ProviderStorage entity.
// If the ProviderStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderStorageMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *ProviderStorageMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetMappings sets the "mappings" field.
func (m *ProviderStorageMutation) SetMappings(tm []types.ProviderMapping) {
	m.mappings = &tm
	m.appendmappings = nil
}

// Mappings returns the value of the "mappings" field in the mutation.
func (m *ProviderStorageMutation) Mappings() (r []types.ProviderMapping, exists bool) {
	v := m.mappings
	if v == nil {
		return
	}
	return *v, true
}

// OldMappings returns the old "mappings" field's value of the ProviderStorage entity.
// If the ProviderStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderStorageMutation) OldMappings(ctx context.Context) (v []types.ProviderMapping, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappings: %w", err)
	}
	return oldValue.Mappings, nil
}

// AppendMappings adds tm to the "mappings" field.
func (m *ProviderStorageMutation) AppendMappings(tm []types.ProviderMapping) {
	m.appendmappings = append(m.appendmappings, tm...)
}

// AppendedMappings returns the list of values that were appended to the "mappings" field in this mutation.
func (m *ProviderStorageMutation) AppendedMappings() ([]types.ProviderMapping, bool) {
	if len(m.appendmappings) == 0 {
		return nil, false
	}
	return m.appendmappings, true
}

// ClearMappings clears the value of the "mappings" field.
func (m *ProviderStorageMutation) ClearMappings() {
	m.mappings = nil
	m.appendmappings = nil
	m.clearedFields[providerstorage.FieldMappings] = struct{}{}
}

// MappingsCleared returns if the "mappings" field was cleared in this mutation.
func (m *ProviderStorageMutation) MappingsCleared() bool {
	_, ok := m.clearedFields[providerstorage.FieldMappings]
	return ok
}

// ResetMappings resets all changes to the "mappings" field.
func (m *ProviderStorageMutation) ResetMappings() {
	m.mappings = nil
	m.appendmappings = nil
	delete(m.clearedFields, providerstorage.FieldMappings)
}

// Where appends a list predicates to the ProviderStorageMutation builder.
func (m *ProviderStorageMutation) Where(ps ...predicate.ProviderStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProviderStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProviderStorage).
func (m *ProviderStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderStorageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.apk_name != nil {
		fields = append(fields, providerstorage.FieldApkName)
	}
	if m.pkg_name != nil {
		fields = append(fields, providerstorage.FieldPkgName)
	}
	if m.name != nil {
		fields = append(fields, providerstorage.FieldName)
	}
	if m.lang != nil {
		fields = append(fields, providerstorage.FieldLang)
	}
	if m.version_code != nil {
		fields = append(fields, providerstorage.FieldVersionCode)
	}
	if m.is_storage != nil {
		fields = append(fields, providerstorage.FieldIsStorage)
	}
	if m.is_disabled != nil {
		fields = append(fields, providerstorage.FieldIsDisabled)
	}
	if m.mappings != nil {
		fields = append(fields, providerstorage.FieldMappings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case providerstorage.FieldApkName:
		return m.ApkName()
	case providerstorage.FieldPkgName:
		return m.PkgName()
	case providerstorage.FieldName:
		return m.Name()
	case providerstorage.FieldLang:
		return m.Lang()
	case providerstorage.FieldVersionCode:
		return m.VersionCode()
	case providerstorage.FieldIsStorage:
		return m.IsStorage()
	case providerstorage.FieldIsDisabled:
		return m.IsDisabled()
	case providerstorage.FieldMappings:
		return m.Mappings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case providerstorage.FieldApkName:
		return m.OldApkName(ctx)
	case providerstorage.FieldPkgName:
		return m.OldPkgName(ctx)
	case providerstorage.FieldName:
		return m.OldName(ctx)
	case providerstorage.FieldLang:
		return m.OldLang(ctx)
	case providerstorage.FieldVersionCode:
		return m.OldVersionCode(ctx)
	case providerstorage.FieldIsStorage:
		return m.OldIsStorage(ctx)
	case providerstorage.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case providerstorage.FieldMappings:
		return m.OldMappings(ctx)
	}
	return nil, fmt.Errorf("unknown ProviderStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case providerstorage.FieldApkName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApkName(v)
		return nil
	case providerstorage.FieldPkgName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgName(v)
		return nil
	case providerstorage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case providerstorage.FieldLang:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLang(v)
		return nil
	case providerstorage.FieldVersionCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionCode(v)
		return nil
	case providerstorage.FieldIsStorage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsStorage(v)
		return nil
	case providerstorage.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case providerstorage.FieldMappings:
		v, ok := value.([]types.ProviderMapping)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappings(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderStorageMutation) AddedFields() []string {
	var fields []string
	if m.addversion_code != nil {
		fields = append(fields, providerstorage.FieldVersionCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case providerstorage.FieldVersionCode:
		return m.AddedVersionCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case providerstorage.FieldVersionCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionCode(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderStorageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(providerstorage.FieldMappings) {
		fields = append(fields, providerstorage.FieldMappings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderStorageMutation) ClearField(name string) error {
	switch name {
	case providerstorage.FieldMappings:
		m.ClearMappings()
		return nil
	}
	return fmt.Errorf("unknown ProviderStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderStorageMutation) ResetField(name string) error {
	switch name {
	case providerstorage.FieldApkName:
		m.ResetApkName()
		return nil
	case providerstorage.FieldPkgName:
		m.ResetPkgName()
		return nil
	case providerstorage.FieldName:
		m.ResetName()
		return nil
	case providerstorage.FieldLang:
		m.ResetLang()
		return nil
	case providerstorage.FieldVersionCode:
		m.ResetVersionCode()
		return nil
	case providerstorage.FieldIsStorage:
		m.ResetIsStorage()
		return nil
	case providerstorage.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case providerstorage.FieldMappings:
		m.ResetMappings()
		return nil
	}
	return fmt.Errorf("unknown ProviderStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderStorageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderStorageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderStorageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderStorageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProviderStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderStorageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProviderStorage edge %s", name)
}

// SeriesMutation represents an operation that mutates the Series nodes in the graph.
type SeriesMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	title                *string
	thumbnail_url        *string
	artist               *string
	author               *string
	description          *string
	genre                *[]string
	appendgenre          []string
	status               *string
	storage_path         *string
	_type                *string
	chapter_count        *int
	addchapter_count     *int
	pause_downloads      *bool
	clearedFields        map[string]struct{}
	providers            map[uuid.UUID]struct{}
	removedproviders     map[uuid.UUID]struct{}
	clearedproviders     bool
	latest_series        map[int]struct{}
	removedlatest_series map[int]struct{}
	clearedlatest_series bool
	done                 bool
	oldValue             func(context.Context) (*Series, error)
	predicates           []predicate.Series
}

var _ ent.Mutation = (*SeriesMutation)(nil)

// seriesOption allows management of the mutation configuration using functional options.
type seriesOption func(*SeriesMutation)

// newSeriesMutation creates new mutation for the Series entity.
func newSeriesMutation(c config, op Op, opts ...seriesOption) *SeriesMutation {
	m := &SeriesMutation{
		config:        c,
		op:            op,
		typ:           TypeSeries,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeriesID sets the ID field of the mutation.
func withSeriesID(id uuid.UUID) seriesOption {
	return func(m *SeriesMutation) {
		var (
			err   error
			once  sync.Once
			value *Series
		)
		m.oldValue = func(ctx context.Context) (*Series, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Series.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeries sets the old Series of the mutation.
func withSeries(node *Series) seriesOption {
	return func(m *SeriesMutation) {
		m.oldValue = func(context.Context) (*Series, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Series entities.
func (m *SeriesMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeriesMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeriesMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Series.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *SeriesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SeriesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SeriesMutation) ResetTitle() {
	m.title = nil
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *SeriesMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *SeriesMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *SeriesMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
}

// SetArtist sets the "artist" field.
func (m *SeriesMutation) SetArtist(s string) {
	m.artist = &s
}

// Artist returns the value of the "artist" field in the mutation.
func (m *SeriesMutation) Artist() (r string, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// ResetArtist resets all changes to the "artist" field.
func (m *SeriesMutation) ResetArtist() {
	m.artist = nil
}

// SetAuthor sets the "author" field.
func (m *SeriesMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *SeriesMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *SeriesMutation) ResetAuthor() {
	m.author = nil
}

// SetDescription sets the "description" field.
func (m *SeriesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SeriesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SeriesMutation) ResetDescription() {
	m.description = nil
}

// SetGenre sets the "genre" field.
func (m *SeriesMutation) SetGenre(s []string) {
	m.genre = &s
	m.appendgenre = nil
}

// Genre returns the value of the "genre" field in the mutation.
func (m *SeriesMutation) Genre() (r []string, exists bool) {
	v := m.genre
	if v == nil {
		return
	}
	return *v, true
}

// OldGenre returns the old "genre" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldGenre(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenre: %w", err)
	}
	return oldValue.Genre, nil
}

// AppendGenre adds s to the "genre" field.
func (m *SeriesMutation) AppendGenre(s []string) {
	m.appendgenre = append(m.appendgenre, s...)
}

// AppendedGenre returns the list of values that were appended to the "genre" field in this mutation.
func (m *SeriesMutation) AppendedGenre() ([]string, bool) {
	if len(m.appendgenre) == 0 {
		return nil, false
	}
	return m.appendgenre, true
}

// ClearGenre clears the value of the "genre" field.
func (m *SeriesMutation) ClearGenre() {
	m.genre = nil
	m.appendgenre = nil
	m.clearedFields[series.FieldGenre] = struct{}{}
}

// GenreCleared returns if the "genre" field was cleared in this mutation.
func (m *SeriesMutation) GenreCleared() bool {
	_, ok := m.clearedFields[series.FieldGenre]
	return ok
}

// ResetGenre resets all changes to the "genre" field.
func (m *SeriesMutation) ResetGenre() {
	m.genre = nil
	m.appendgenre = nil
	delete(m.clearedFields, series.FieldGenre)
}

// SetStatus sets the "status" field.
func (m *SeriesMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SeriesMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SeriesMutation) ResetStatus() {
	m.status = nil
}

// SetStoragePath sets the "storage_path" field.
func (m *SeriesMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *SeriesMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ClearStoragePath clears the value of the "storage_path" field.
func (m *SeriesMutation) ClearStoragePath() {
	m.storage_path = nil
	m.clearedFields[series.FieldStoragePath] = struct{}{}
}

// StoragePathCleared returns if the "storage_path" field was cleared in this mutation.
func (m *SeriesMutation) StoragePathCleared() bool {
	_, ok := m.clearedFields[series.FieldStoragePath]
	return ok
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *SeriesMutation) ResetStoragePath() {
	m.storage_path = nil
	delete(m.clearedFields, series.FieldStoragePath)
}

// SetType sets the "type" field.
func (m *SeriesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SeriesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *SeriesMutation) ClearType() {
	m._type = nil
	m.clearedFields[series.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *SeriesMutation) TypeCleared() bool {
	_, ok := m.clearedFields[series.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *SeriesMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, series.FieldType)
}

// SetChapterCount sets the "chapter_count" field.
func (m *SeriesMutation) SetChapterCount(i int) {
	m.chapter_count = &i
	m.addchapter_count = nil
}

// ChapterCount returns the value of the "chapter_count" field in the mutation.
func (m *SeriesMutation) ChapterCount() (r int, exists bool) {
	v := m.chapter_count
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterCount returns the old "chapter_count" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldChapterCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterCount: %w", err)
	}
	return oldValue.ChapterCount, nil
}

// AddChapterCount adds i to the "chapter_count" field.
func (m *SeriesMutation) AddChapterCount(i int) {
	if m.addchapter_count != nil {
		*m.addchapter_count += i
	} else {
		m.addchapter_count = &i
	}
}

// AddedChapterCount returns the value that was added to the "chapter_count" field in this mutation.
func (m *SeriesMutation) AddedChapterCount() (r int, exists bool) {
	v := m.addchapter_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetChapterCount resets all changes to the "chapter_count" field.
func (m *SeriesMutation) ResetChapterCount() {
	m.chapter_count = nil
	m.addchapter_count = nil
}

// SetPauseDownloads sets the "pause_downloads" field.
func (m *SeriesMutation) SetPauseDownloads(b bool) {
	m.pause_downloads = &b
}

// PauseDownloads returns the value of the "pause_downloads" field in the mutation.
func (m *SeriesMutation) PauseDownloads() (r bool, exists bool) {
	v := m.pause_downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldPauseDownloads returns the old "pause_downloads" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldPauseDownloads(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPauseDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPauseDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPauseDownloads: %w", err)
	}
	return oldValue.PauseDownloads, nil
}

// ResetPauseDownloads resets all changes to the "pause_downloads" field.
func (m *SeriesMutation) ResetPauseDownloads() {
	m.pause_downloads = nil
}

// AddProviderIDs adds the "providers" edge to the SeriesProvider entity by ids.
func (m *SeriesMutation) AddProviderIDs(ids ...uuid.UUID) {
	if m.providers == nil {
		m.providers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.providers[ids[i]] = struct{}{}
	}
}

// ClearProviders clears the "providers" edge to the SeriesProvider entity.
func (m *SeriesMutation) ClearProviders() {
	m.clearedproviders = true
}

// ProvidersCleared reports if the "providers" edge to the SeriesProvider entity was cleared.
func (m *SeriesMutation) ProvidersCleared() bool {
	return m.clearedproviders
}

// RemoveProviderIDs removes the "providers" edge to the SeriesProvider entity by IDs.
func (m *SeriesMutation) RemoveProviderIDs(ids ...uuid.UUID) {
	if m.removedproviders == nil {
		m.removedproviders = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.providers, ids[i])
		m.removedproviders[ids[i]] = struct{}{}
	}
}

// RemovedProviders returns the removed IDs of the "providers" edge to the SeriesProvider entity.
func (m *SeriesMutation) RemovedProvidersIDs() (ids []uuid.UUID) {
	for id := range m.removedproviders {
		ids = append(ids, id)
	}
	return
}

// ProvidersIDs returns the "providers" edge IDs in the mutation.
func (m *SeriesMutation) ProvidersIDs() (ids []uuid.UUID) {
	for id := range m.providers {
		ids = append(ids, id)
	}
	return
}

// ResetProviders resets all changes to the "providers" edge.
func (m *SeriesMutation) ResetProviders() {
	m.providers = nil
	m.clearedproviders = false
	m.removedproviders = nil
}

// AddLatestSeriesIDs adds the "latest_series" edge to the LatestSeries entity by ids.
func (m *SeriesMutation) AddLatestSeriesIDs(ids ...int) {
	if m.latest_series == nil {
		m.latest_series = make(map[int]struct{})
	}
	for i := range ids {
		m.latest_series[ids[i]] = struct{}{}
	}
}

// ClearLatestSeries clears the "latest_series" edge to the LatestSeries entity.
func (m *SeriesMutation) ClearLatestSeries() {
	m.clearedlatest_series = true
}

// LatestSeriesCleared reports if the "latest_series" edge to the LatestSeries entity was cleared.
func (m *SeriesMutation) LatestSeriesCleared() bool {
	return m.clearedlatest_series
}

// RemoveLatestSeriesIDs removes the "latest_series" edge to the LatestSeries entity by IDs.
func (m *SeriesMutation) RemoveLatestSeriesIDs(ids ...int) {
	if m.removedlatest_series == nil {
		m.removedlatest_series = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.latest_series, ids[i])
		m.removedlatest_series[ids[i]] = struct{}{}
	}
}

// RemovedLatestSeries returns the removed IDs of the "latest_series" edge to the LatestSeries entity.
func (m *SeriesMutation) RemovedLatestSeriesIDs() (ids []int) {
	for id := range m.removedlatest_series {
		ids = append(ids, id)
	}
	return
}

// LatestSeriesIDs returns the "latest_series" edge IDs in the mutation.
func (m *SeriesMutation) LatestSeriesIDs() (ids []int) {
	for id := range m.latest_series {
		ids = append(ids, id)
	}
	return
}

// ResetLatestSeries resets all changes to the "latest_series" edge.
func (m *SeriesMutation) ResetLatestSeries() {
	m.latest_series = nil
	m.clearedlatest_series = false
	m.removedlatest_series = nil
}

// Where appends a list predicates to the SeriesMutation builder.
func (m *SeriesMutation) Where(ps ...predicate.Series) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Series, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Series).
func (m *SeriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeriesMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, series.FieldTitle)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, series.FieldThumbnailURL)
	}
	if m.artist != nil {
		fields = append(fields, series.FieldArtist)
	}
	if m.author != nil {
		fields = append(fields, series.FieldAuthor)
	}
	if m.description != nil {
		fields = append(fields, series.FieldDescription)
	}
	if m.genre != nil {
		fields = append(fields, series.FieldGenre)
	}
	if m.status != nil {
		fields = append(fields, series.FieldStatus)
	}
	if m.storage_path != nil {
		fields = append(fields, series.FieldStoragePath)
	}
	if m._type != nil {
		fields = append(fields, series.FieldType)
	}
	if m.chapter_count != nil {
		fields = append(fields, series.FieldChapterCount)
	}
	if m.pause_downloads != nil {
		fields = append(fields, series.FieldPauseDownloads)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case series.FieldTitle:
		return m.Title()
	case series.FieldThumbnailURL:
		return m.ThumbnailURL()
	case series.FieldArtist:
		return m.Artist()
	case series.FieldAuthor:
		return m.Author()
	case series.FieldDescription:
		return m.Description()
	case series.FieldGenre:
		return m.Genre()
	case series.FieldStatus:
		return m.Status()
	case series.FieldStoragePath:
		return m.StoragePath()
	case series.FieldType:
		return m.GetType()
	case series.FieldChapterCount:
		return m.ChapterCount()
	case series.FieldPauseDownloads:
		return m.PauseDownloads()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case series.FieldTitle:
		return m.OldTitle(ctx)
	case series.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case series.FieldArtist:
		return m.OldArtist(ctx)
	case series.FieldAuthor:
		return m.OldAuthor(ctx)
	case series.FieldDescription:
		return m.OldDescription(ctx)
	case series.FieldGenre:
		return m.OldGenre(ctx)
	case series.FieldStatus:
		return m.OldStatus(ctx)
	case series.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case series.FieldType:
		return m.OldType(ctx)
	case series.FieldChapterCount:
		return m.OldChapterCount(ctx)
	case series.FieldPauseDownloads:
		return m.OldPauseDownloads(ctx)
	}
	return nil, fmt.Errorf("unknown Series field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case series.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case series.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case series.FieldArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case series.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case series.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case series.FieldGenre:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenre(v)
		return nil
	case series.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case series.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case series.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case series.FieldChapterCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterCount(v)
		return nil
	case series.FieldPauseDownloads:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPauseDownloads(v)
		return nil
	}
	return fmt.Errorf("unknown Series field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeriesMutation) AddedFields() []string {
	var fields []string
	if m.addchapter_count != nil {
		fields = append(fields, series.FieldChapterCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case series.FieldChapterCount:
		return m.AddedChapterCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case series.FieldChapterCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterCount(v)
		return nil
	}
	return fmt.Errorf("unknown Series numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(series.FieldGenre) {
		fields = append(fields, series.FieldGenre)
	}
	if m.FieldCleared(series.FieldStoragePath) {
		fields = append(fields, series.FieldStoragePath)
	}
	if m.FieldCleared(series.FieldType) {
		fields = append(fields, series.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeriesMutation) ClearField(name string) error {
	switch name {
	case series.FieldGenre:
		m.ClearGenre()
		return nil
	case series.FieldStoragePath:
		m.ClearStoragePath()
		return nil
	case series.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Series nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeriesMutation) ResetField(name string) error {
	switch name {
	case series.FieldTitle:
		m.ResetTitle()
		return nil
	case series.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case series.FieldArtist:
		m.ResetArtist()
		return nil
	case series.FieldAuthor:
		m.ResetAuthor()
		return nil
	case series.FieldDescription:
		m.ResetDescription()
		return nil
	case series.FieldGenre:
		m.ResetGenre()
		return nil
	case series.FieldStatus:
		m.ResetStatus()
		return nil
	case series.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case series.FieldType:
		m.ResetType()
		return nil
	case series.FieldChapterCount:
		m.ResetChapterCount()
		return nil
	case series.FieldPauseDownloads:
		m.ResetPauseDownloads()
		return nil
	}
	return fmt.Errorf("unknown Series field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.providers != nil {
		edges = append(edges, series.EdgeProviders)
	}
	if m.latest_series != nil {
		edges = append(edges, series.EdgeLatestSeries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case series.EdgeProviders:
		ids := make([]ent.Value, 0, len(m.providers))
		for id := range m.providers {
			ids = append(ids, id)
		}
		return ids
	case series.EdgeLatestSeries:
		ids := make([]ent.Value, 0, len(m.latest_series))
		for id := range m.latest_series {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproviders != nil {
		edges = append(edges, series.EdgeProviders)
	}
	if m.removedlatest_series != nil {
		edges = append(edges, series.EdgeLatestSeries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeriesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case series.EdgeProviders:
		ids := make([]ent.Value, 0, len(m.removedproviders))
		for id := range m.removedproviders {
			ids = append(ids, id)
		}
		return ids
	case series.EdgeLatestSeries:
		ids := make([]ent.Value, 0, len(m.removedlatest_series))
		for id := range m.removedlatest_series {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproviders {
		edges = append(edges, series.EdgeProviders)
	}
	if m.clearedlatest_series {
		edges = append(edges, series.EdgeLatestSeries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeriesMutation) EdgeCleared(name string) bool {
	switch name {
	case series.EdgeProviders:
		return m.clearedproviders
	case series.EdgeLatestSeries:
		return m.clearedlatest_series
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeriesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Series unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeriesMutation) ResetEdge(name string) error {
	switch name {
	case series.EdgeProviders:
		m.ResetProviders()
		return nil
	case series.EdgeLatestSeries:
		m.ResetLatestSeries()
		return nil
	}
	return fmt.Errorf("unknown Series edge %s", name)
}

// SeriesProviderMutation represents an operation that mutates the SeriesProvider nodes in the graph.
type SeriesProviderMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	suwayomi_id               *int
	addsuwayomi_id            *int
	provider                  *string
	scanlator                 *string
	url                       *string
	title                     *string
	language                  *string
	thumbnail_url             *string
	artist                    *string
	author                    *string
	description               *string
	genre                     *[]string
	appendgenre               []string
	fetch_date                *time.Time
	chapter_count             *int64
	addchapter_count          *int64
	continue_after_chapter    *float64
	addcontinue_after_chapter *float64
	is_title                  *bool
	is_cover                  *bool
	is_unknown                *bool
	importance                *int
	addimportance             *int
	is_disabled               *bool
	is_uninstalled            *bool
	status                    *string
	chapters                  *[]types.Chapter
	appendchapters            []types.Chapter
	clearedFields             map[string]struct{}
	series                    *uuid.UUID
	clearedseries             bool
	done                      bool
	oldValue                  func(context.Context) (*SeriesProvider, error)
	predicates                []predicate.SeriesProvider
}

var _ ent.Mutation = (*SeriesProviderMutation)(nil)

// seriesproviderOption allows management of the mutation configuration using functional options.
type seriesproviderOption func(*SeriesProviderMutation)

// newSeriesProviderMutation creates new mutation for the SeriesProvider entity.
func newSeriesProviderMutation(c config, op Op, opts ...seriesproviderOption) *SeriesProviderMutation {
	m := &SeriesProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeSeriesProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeriesProviderID sets the ID field of the mutation.
func withSeriesProviderID(id uuid.UUID) seriesproviderOption {
	return func(m *SeriesProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *SeriesProvider
		)
		m.oldValue = func(ctx context.Context) (*SeriesProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SeriesProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeriesProvider sets the old SeriesProvider of the mutation.
func withSeriesProvider(node *SeriesProvider) seriesproviderOption {
	return func(m *SeriesProviderMutation) {
		m.oldValue = func(context.Context) (*SeriesProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeriesProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeriesProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SeriesProvider entities.
func (m *SeriesProviderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeriesProviderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeriesProviderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SeriesProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeriesID sets the "series_id" field.
func (m *SeriesProviderMutation) SetSeriesID(u uuid.UUID) {
	m.series = &u
}

// SeriesID returns the value of the "series_id" field in the mutation.
func (m *SeriesProviderMutation) SeriesID() (r uuid.UUID, exists bool) {
	v := m.series
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesID returns the old "series_id" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldSeriesID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesID: %w", err)
	}
	return oldValue.SeriesID, nil
}

// ResetSeriesID resets all changes to the "series_id" field.
func (m *SeriesProviderMutation) ResetSeriesID() {
	m.series = nil
}

// SetSuwayomiID sets the "suwayomi_id" field.
func (m *SeriesProviderMutation) SetSuwayomiID(i int) {
	m.suwayomi_id = &i
	m.addsuwayomi_id = nil
}

// SuwayomiID returns the value of the "suwayomi_id" field in the mutation.
func (m *SeriesProviderMutation) SuwayomiID() (r int, exists bool) {
	v := m.suwayomi_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSuwayomiID returns the old "suwayomi_id" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldSuwayomiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuwayomiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuwayomiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuwayomiID: %w", err)
	}
	return oldValue.SuwayomiID, nil
}

// AddSuwayomiID adds i to the "suwayomi_id" field.
func (m *SeriesProviderMutation) AddSuwayomiID(i int) {
	if m.addsuwayomi_id != nil {
		*m.addsuwayomi_id += i
	} else {
		m.addsuwayomi_id = &i
	}
}

// AddedSuwayomiID returns the value that was added to the "suwayomi_id" field in this mutation.
func (m *SeriesProviderMutation) AddedSuwayomiID() (r int, exists bool) {
	v := m.addsuwayomi_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuwayomiID resets all changes to the "suwayomi_id" field.
func (m *SeriesProviderMutation) ResetSuwayomiID() {
	m.suwayomi_id = nil
	m.addsuwayomi_id = nil
}

// SetProvider sets the "provider" field.
func (m *SeriesProviderMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *SeriesProviderMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *SeriesProviderMutation) ResetProvider() {
	m.provider = nil
}

// SetScanlator sets the "scanlator" field.
func (m *SeriesProviderMutation) SetScanlator(s string) {
	m.scanlator = &s
}

// Scanlator returns the value of the "scanlator" field in the mutation.
func (m *SeriesProviderMutation) Scanlator() (r string, exists bool) {
	v := m.scanlator
	if v == nil {
		return
	}
	return *v, true
}

// OldScanlator returns the old "scanlator" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldScanlator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScanlator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScanlator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScanlator: %w", err)
	}
	return oldValue.Scanlator, nil
}

// ResetScanlator resets all changes to the "scanlator" field.
func (m *SeriesProviderMutation) ResetScanlator() {
	m.scanlator = nil
}

// SetURL sets the "url" field.
func (m *SeriesProviderMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SeriesProviderMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *SeriesProviderMutation) ClearURL() {
	m.url = nil
	m.clearedFields[seriesprovider.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *SeriesProviderMutation) URLCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *SeriesProviderMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, seriesprovider.FieldURL)
}

// SetTitle sets the "title" field.
func (m *SeriesProviderMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SeriesProviderMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SeriesProviderMutation) ResetTitle() {
	m.title = nil
}

// SetLanguage sets the "language" field.
func (m *SeriesProviderMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *SeriesProviderMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *SeriesProviderMutation) ResetLanguage() {
	m.language = nil
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *SeriesProviderMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *SeriesProviderMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldThumbnailURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *SeriesProviderMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[seriesprovider.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *SeriesProviderMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *SeriesProviderMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, seriesprovider.FieldThumbnailURL)
}

// SetArtist sets the "artist" field.
func (m *SeriesProviderMutation) SetArtist(s string) {
	m.artist = &s
}

// Artist returns the value of the "artist" field in the mutation.
func (m *SeriesProviderMutation) Artist() (r string, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldArtist(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// ClearArtist clears the value of the "artist" field.
func (m *SeriesProviderMutation) ClearArtist() {
	m.artist = nil
	m.clearedFields[seriesprovider.FieldArtist] = struct{}{}
}

// ArtistCleared returns if the "artist" field was cleared in this mutation.
func (m *SeriesProviderMutation) ArtistCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldArtist]
	return ok
}

// ResetArtist resets all changes to the "artist" field.
func (m *SeriesProviderMutation) ResetArtist() {
	m.artist = nil
	delete(m.clearedFields, seriesprovider.FieldArtist)
}

// SetAuthor sets the "author" field.
func (m *SeriesProviderMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *SeriesProviderMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldAuthor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *SeriesProviderMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[seriesprovider.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *SeriesProviderMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *SeriesProviderMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, seriesprovider.FieldAuthor)
}

// SetDescription sets the "description" field.
func (m *SeriesProviderMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SeriesProviderMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SeriesProviderMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[seriesprovider.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SeriesProviderMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SeriesProviderMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, seriesprovider.FieldDescription)
}

// SetGenre sets the "genre" field.
func (m *SeriesProviderMutation) SetGenre(s []string) {
	m.genre = &s
	m.appendgenre = nil
}

// Genre returns the value of the "genre" field in the mutation.
func (m *SeriesProviderMutation) Genre() (r []string, exists bool) {
	v := m.genre
	if v == nil {
		return
	}
	return *v, true
}

// OldGenre returns the old "genre" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldGenre(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenre: %w", err)
	}
	return oldValue.Genre, nil
}

// AppendGenre adds s to the "genre" field.
func (m *SeriesProviderMutation) AppendGenre(s []string) {
	m.appendgenre = append(m.appendgenre, s...)
}

// AppendedGenre returns the list of values that were appended to the "genre" field in this mutation.
func (m *SeriesProviderMutation) AppendedGenre() ([]string, bool) {
	if len(m.appendgenre) == 0 {
		return nil, false
	}
	return m.appendgenre, true
}

// ClearGenre clears the value of the "genre" field.
func (m *SeriesProviderMutation) ClearGenre() {
	m.genre = nil
	m.appendgenre = nil
	m.clearedFields[seriesprovider.FieldGenre] = struct{}{}
}

// GenreCleared returns if the "genre" field was cleared in this mutation.
func (m *SeriesProviderMutation) GenreCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldGenre]
	return ok
}

// ResetGenre resets all changes to the "genre" field.
func (m *SeriesProviderMutation) ResetGenre() {
	m.genre = nil
	m.appendgenre = nil
	delete(m.clearedFields, seriesprovider.FieldGenre)
}

// SetFetchDate sets the "fetch_date" field.
func (m *SeriesProviderMutation) SetFetchDate(t time.Time) {
	m.fetch_date = &t
}

// FetchDate returns the value of the "fetch_date" field in the mutation.
func (m *SeriesProviderMutation) FetchDate() (r time.Time, exists bool) {
	v := m.fetch_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFetchDate returns the old "fetch_date" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldFetchDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFetchDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFetchDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFetchDate: %w", err)
	}
	return oldValue.FetchDate, nil
}

// ClearFetchDate clears the value of the "fetch_date" field.
func (m *SeriesProviderMutation) ClearFetchDate() {
	m.fetch_date = nil
	m.clearedFields[seriesprovider.FieldFetchDate] = struct{}{}
}

// FetchDateCleared returns if the "fetch_date" field was cleared in this mutation.
func (m *SeriesProviderMutation) FetchDateCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldFetchDate]
	return ok
}

// ResetFetchDate resets all changes to the "fetch_date" field.
func (m *SeriesProviderMutation) ResetFetchDate() {
	m.fetch_date = nil
	delete(m.clearedFields, seriesprovider.FieldFetchDate)
}

// SetChapterCount sets the "chapter_count" field.
func (m *SeriesProviderMutation) SetChapterCount(i int64) {
	m.chapter_count = &i
	m.addchapter_count = nil
}

// ChapterCount returns the value of the "chapter_count" field in the mutation.
func (m *SeriesProviderMutation) ChapterCount() (r int64, exists bool) {
	v := m.chapter_count
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterCount returns the old "chapter_count" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldChapterCount(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterCount: %w", err)
	}
	return oldValue.ChapterCount, nil
}

// AddChapterCount adds i to the "chapter_count" field.
func (m *SeriesProviderMutation) AddChapterCount(i int64) {
	if m.addchapter_count != nil {
		*m.addchapter_count += i
	} else {
		m.addchapter_count = &i
	}
}

// AddedChapterCount returns the value that was added to the "chapter_count" field in this mutation.
func (m *SeriesProviderMutation) AddedChapterCount() (r int64, exists bool) {
	v := m.addchapter_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterCount clears the value of the "chapter_count" field.
func (m *SeriesProviderMutation) ClearChapterCount() {
	m.chapter_count = nil
	m.addchapter_count = nil
	m.clearedFields[seriesprovider.FieldChapterCount] = struct{}{}
}

// ChapterCountCleared returns if the "chapter_count" field was cleared in this mutation.
func (m *SeriesProviderMutation) ChapterCountCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldChapterCount]
	return ok
}

// ResetChapterCount resets all changes to the "chapter_count" field.
func (m *SeriesProviderMutation) ResetChapterCount() {
	m.chapter_count = nil
	m.addchapter_count = nil
	delete(m.clearedFields, seriesprovider.FieldChapterCount)
}

// SetContinueAfterChapter sets the "continue_after_chapter" field.
func (m *SeriesProviderMutation) SetContinueAfterChapter(f float64) {
	m.continue_after_chapter = &f
	m.addcontinue_after_chapter = nil
}

// ContinueAfterChapter returns the value of the "continue_after_chapter" field in the mutation.
func (m *SeriesProviderMutation) ContinueAfterChapter() (r float64, exists bool) {
	v := m.continue_after_chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldContinueAfterChapter returns the old "continue_after_chapter" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldContinueAfterChapter(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinueAfterChapter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinueAfterChapter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinueAfterChapter: %w", err)
	}
	return oldValue.ContinueAfterChapter, nil
}

// AddContinueAfterChapter adds f to the "continue_after_chapter" field.
func (m *SeriesProviderMutation) AddContinueAfterChapter(f float64) {
	if m.addcontinue_after_chapter != nil {
		*m.addcontinue_after_chapter += f
	} else {
		m.addcontinue_after_chapter = &f
	}
}

// AddedContinueAfterChapter returns the value that was added to the "continue_after_chapter" field in this mutation.
func (m *SeriesProviderMutation) AddedContinueAfterChapter() (r float64, exists bool) {
	v := m.addcontinue_after_chapter
	if v == nil {
		return
	}
	return *v, true
}

// ClearContinueAfterChapter clears the value of the "continue_after_chapter" field.
func (m *SeriesProviderMutation) ClearContinueAfterChapter() {
	m.continue_after_chapter = nil
	m.addcontinue_after_chapter = nil
	m.clearedFields[seriesprovider.FieldContinueAfterChapter] = struct{}{}
}

// ContinueAfterChapterCleared returns if the "continue_after_chapter" field was cleared in this mutation.
func (m *SeriesProviderMutation) ContinueAfterChapterCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldContinueAfterChapter]
	return ok
}

// ResetContinueAfterChapter resets all changes to the "continue_after_chapter" field.
func (m *SeriesProviderMutation) ResetContinueAfterChapter() {
	m.continue_after_chapter = nil
	m.addcontinue_after_chapter = nil
	delete(m.clearedFields, seriesprovider.FieldContinueAfterChapter)
}

// SetIsTitle sets the "is_title" field.
func (m *SeriesProviderMutation) SetIsTitle(b bool) {
	m.is_title = &b
}

// IsTitle returns the value of the "is_title" field in the mutation.
func (m *SeriesProviderMutation) IsTitle() (r bool, exists bool) {
	v := m.is_title
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTitle returns the old "is_title" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldIsTitle(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTitle: %w", err)
	}
	return oldValue.IsTitle, nil
}

// ResetIsTitle resets all changes to the "is_title" field.
func (m *SeriesProviderMutation) ResetIsTitle() {
	m.is_title = nil
}

// SetIsCover sets the "is_cover" field.
func (m *SeriesProviderMutation) SetIsCover(b bool) {
	m.is_cover = &b
}

// IsCover returns the value of the "is_cover" field in the mutation.
func (m *SeriesProviderMutation) IsCover() (r bool, exists bool) {
	v := m.is_cover
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCover returns the old "is_cover" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldIsCover(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCover: %w", err)
	}
	return oldValue.IsCover, nil
}

// ResetIsCover resets all changes to the "is_cover" field.
func (m *SeriesProviderMutation) ResetIsCover() {
	m.is_cover = nil
}

// SetIsUnknown sets the "is_unknown" field.
func (m *SeriesProviderMutation) SetIsUnknown(b bool) {
	m.is_unknown = &b
}

// IsUnknown returns the value of the "is_unknown" field in the mutation.
func (m *SeriesProviderMutation) IsUnknown() (r bool, exists bool) {
	v := m.is_unknown
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUnknown returns the old "is_unknown" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldIsUnknown(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUnknown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUnknown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUnknown: %w", err)
	}
	return oldValue.IsUnknown, nil
}

// ResetIsUnknown resets all changes to the "is_unknown" field.
func (m *SeriesProviderMutation) ResetIsUnknown() {
	m.is_unknown = nil
}

// SetImportance sets the "importance" field.
func (m *SeriesProviderMutation) SetImportance(i int) {
	m.importance = &i
	m.addimportance = nil
}

// Importance returns the value of the "importance" field in the mutation.
func (m *SeriesProviderMutation) Importance() (r int, exists bool) {
	v := m.importance
	if v == nil {
		return
	}
	return *v, true
}

// OldImportance returns the old "importance" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldImportance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportance: %w", err)
	}
	return oldValue.Importance, nil
}

// AddImportance adds i to the "importance" field.
func (m *SeriesProviderMutation) AddImportance(i int) {
	if m.addimportance != nil {
		*m.addimportance += i
	} else {
		m.addimportance = &i
	}
}

// AddedImportance returns the value that was added to the "importance" field in this mutation.
func (m *SeriesProviderMutation) AddedImportance() (r int, exists bool) {
	v := m.addimportance
	if v == nil {
		return
	}
	return *v, true
}

// ResetImportance resets all changes to the "importance" field.
func (m *SeriesProviderMutation) ResetImportance() {
	m.importance = nil
	m.addimportance = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *SeriesProviderMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *SeriesProviderMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *SeriesProviderMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetIsUninstalled sets the "is_uninstalled" field.
func (m *SeriesProviderMutation) SetIsUninstalled(b bool) {
	m.is_uninstalled = &b
}

// IsUninstalled returns the value of the "is_uninstalled" field in the mutation.
func (m *SeriesProviderMutation) IsUninstalled() (r bool, exists bool) {
	v := m.is_uninstalled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUninstalled returns the old "is_uninstalled" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldIsUninstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUninstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUninstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUninstalled: %w", err)
	}
	return oldValue.IsUninstalled, nil
}

// ResetIsUninstalled resets all changes to the "is_uninstalled" field.
func (m *SeriesProviderMutation) ResetIsUninstalled() {
	m.is_uninstalled = nil
}

// SetStatus sets the "status" field.
func (m *SeriesProviderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SeriesProviderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SeriesProviderMutation) ResetStatus() {
	m.status = nil
}

// SetChapters sets the "chapters" field.
func (m *SeriesProviderMutation) SetChapters(t []types.Chapter) {
	m.chapters = &t
	m.appendchapters = nil
}

// Chapters returns the value of the "chapters" field in the mutation.
func (m *SeriesProviderMutation) Chapters() (r []types.Chapter, exists bool) {
	v := m.chapters
	if v == nil {
		return
	}
	return *v, true
}

// OldChapters returns the old "chapters" field's value of the SeriesProvider entity.
// If the SeriesProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesProviderMutation) OldChapters(ctx context.Context) (v []types.Chapter, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapters: %w", err)
	}
	return oldValue.Chapters, nil
}

// AppendChapters adds t to the "chapters" field.
func (m *SeriesProviderMutation) AppendChapters(t []types.Chapter) {
	m.appendchapters = append(m.appendchapters, t...)
}

// AppendedChapters returns the list of values that were appended to the "chapters" field in this mutation.
func (m *SeriesProviderMutation) AppendedChapters() ([]types.Chapter, bool) {
	if len(m.appendchapters) == 0 {
		return nil, false
	}
	return m.appendchapters, true
}

// ClearChapters clears the value of the "chapters" field.
func (m *SeriesProviderMutation) ClearChapters() {
	m.chapters = nil
	m.appendchapters = nil
	m.clearedFields[seriesprovider.FieldChapters] = struct{}{}
}

// ChaptersCleared returns if the "chapters" field was cleared in this mutation.
func (m *SeriesProviderMutation) ChaptersCleared() bool {
	_, ok := m.clearedFields[seriesprovider.FieldChapters]
	return ok
}

// ResetChapters resets all changes to the "chapters" field.
func (m *SeriesProviderMutation) ResetChapters() {
	m.chapters = nil
	m.appendchapters = nil
	delete(m.clearedFields, seriesprovider.FieldChapters)
}

// ClearSeries clears the "series" edge to the Series entity.
func (m *SeriesProviderMutation) ClearSeries() {
	m.clearedseries = true
	m.clearedFields[seriesprovider.FieldSeriesID] = struct{}{}
}

// SeriesCleared reports if the "series" edge to the Series entity was cleared.
func (m *SeriesProviderMutation) SeriesCleared() bool {
	return m.clearedseries
}

// SeriesIDs returns the "series" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeriesID instead. It exists only for internal usage by the builders.
func (m *SeriesProviderMutation) SeriesIDs() (ids []uuid.UUID) {
	if id := m.series; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeries resets all changes to the "series" edge.
func (m *SeriesProviderMutation) ResetSeries() {
	m.series = nil
	m.clearedseries = false
}

// Where appends a list predicates to the SeriesProviderMutation builder.
func (m *SeriesProviderMutation) Where(ps ...predicate.SeriesProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeriesProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeriesProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SeriesProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeriesProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeriesProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SeriesProvider).
func (m *SeriesProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeriesProviderMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.series != nil {
		fields = append(fields, seriesprovider.FieldSeriesID)
	}
	if m.suwayomi_id != nil {
		fields = append(fields, seriesprovider.FieldSuwayomiID)
	}
	if m.provider != nil {
		fields = append(fields, seriesprovider.FieldProvider)
	}
	if m.scanlator != nil {
		fields = append(fields, seriesprovider.FieldScanlator)
	}
	if m.url != nil {
		fields = append(fields, seriesprovider.FieldURL)
	}
	if m.title != nil {
		fields = append(fields, seriesprovider.FieldTitle)
	}
	if m.language != nil {
		fields = append(fields, seriesprovider.FieldLanguage)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, seriesprovider.FieldThumbnailURL)
	}
	if m.artist != nil {
		fields = append(fields, seriesprovider.FieldArtist)
	}
	if m.author != nil {
		fields = append(fields, seriesprovider.FieldAuthor)
	}
	if m.description != nil {
		fields = append(fields, seriesprovider.FieldDescription)
	}
	if m.genre != nil {
		fields = append(fields, seriesprovider.FieldGenre)
	}
	if m.fetch_date != nil {
		fields = append(fields, seriesprovider.FieldFetchDate)
	}
	if m.chapter_count != nil {
		fields = append(fields, seriesprovider.FieldChapterCount)
	}
	if m.continue_after_chapter != nil {
		fields = append(fields, seriesprovider.FieldContinueAfterChapter)
	}
	if m.is_title != nil {
		fields = append(fields, seriesprovider.FieldIsTitle)
	}
	if m.is_cover != nil {
		fields = append(fields, seriesprovider.FieldIsCover)
	}
	if m.is_unknown != nil {
		fields = append(fields, seriesprovider.FieldIsUnknown)
	}
	if m.importance != nil {
		fields = append(fields, seriesprovider.FieldImportance)
	}
	if m.is_disabled != nil {
		fields = append(fields, seriesprovider.FieldIsDisabled)
	}
	if m.is_uninstalled != nil {
		fields = append(fields, seriesprovider.FieldIsUninstalled)
	}
	if m.status != nil {
		fields = append(fields, seriesprovider.FieldStatus)
	}
	if m.chapters != nil {
		fields = append(fields, seriesprovider.FieldChapters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeriesProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seriesprovider.FieldSeriesID:
		return m.SeriesID()
	case seriesprovider.FieldSuwayomiID:
		return m.SuwayomiID()
	case seriesprovider.FieldProvider:
		return m.Provider()
	case seriesprovider.FieldScanlator:
		return m.Scanlator()
	case seriesprovider.FieldURL:
		return m.URL()
	case seriesprovider.FieldTitle:
		return m.Title()
	case seriesprovider.FieldLanguage:
		return m.Language()
	case seriesprovider.FieldThumbnailURL:
		return m.ThumbnailURL()
	case seriesprovider.FieldArtist:
		return m.Artist()
	case seriesprovider.FieldAuthor:
		return m.Author()
	case seriesprovider.FieldDescription:
		return m.Description()
	case seriesprovider.FieldGenre:
		return m.Genre()
	case seriesprovider.FieldFetchDate:
		return m.FetchDate()
	case seriesprovider.FieldChapterCount:
		return m.ChapterCount()
	case seriesprovider.FieldContinueAfterChapter:
		return m.ContinueAfterChapter()
	case seriesprovider.FieldIsTitle:
		return m.IsTitle()
	case seriesprovider.FieldIsCover:
		return m.IsCover()
	case seriesprovider.FieldIsUnknown:
		return m.IsUnknown()
	case seriesprovider.FieldImportance:
		return m.Importance()
	case seriesprovider.FieldIsDisabled:
		return m.IsDisabled()
	case seriesprovider.FieldIsUninstalled:
		return m.IsUninstalled()
	case seriesprovider.FieldStatus:
		return m.Status()
	case seriesprovider.FieldChapters:
		return m.Chapters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeriesProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seriesprovider.FieldSeriesID:
		return m.OldSeriesID(ctx)
	case seriesprovider.FieldSuwayomiID:
		return m.OldSuwayomiID(ctx)
	case seriesprovider.FieldProvider:
		return m.OldProvider(ctx)
	case seriesprovider.FieldScanlator:
		return m.OldScanlator(ctx)
	case seriesprovider.FieldURL:
		return m.OldURL(ctx)
	case seriesprovider.FieldTitle:
		return m.OldTitle(ctx)
	case seriesprovider.FieldLanguage:
		return m.OldLanguage(ctx)
	case seriesprovider.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case seriesprovider.FieldArtist:
		return m.OldArtist(ctx)
	case seriesprovider.FieldAuthor:
		return m.OldAuthor(ctx)
	case seriesprovider.FieldDescription:
		return m.OldDescription(ctx)
	case seriesprovider.FieldGenre:
		return m.OldGenre(ctx)
	case seriesprovider.FieldFetchDate:
		return m.OldFetchDate(ctx)
	case seriesprovider.FieldChapterCount:
		return m.OldChapterCount(ctx)
	case seriesprovider.FieldContinueAfterChapter:
		return m.OldContinueAfterChapter(ctx)
	case seriesprovider.FieldIsTitle:
		return m.OldIsTitle(ctx)
	case seriesprovider.FieldIsCover:
		return m.OldIsCover(ctx)
	case seriesprovider.FieldIsUnknown:
		return m.OldIsUnknown(ctx)
	case seriesprovider.FieldImportance:
		return m.OldImportance(ctx)
	case seriesprovider.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case seriesprovider.FieldIsUninstalled:
		return m.OldIsUninstalled(ctx)
	case seriesprovider.FieldStatus:
		return m.OldStatus(ctx)
	case seriesprovider.FieldChapters:
		return m.OldChapters(ctx)
	}
	return nil, fmt.Errorf("unknown SeriesProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seriesprovider.FieldSeriesID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesID(v)
		return nil
	case seriesprovider.FieldSuwayomiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuwayomiID(v)
		return nil
	case seriesprovider.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case seriesprovider.FieldScanlator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScanlator(v)
		return nil
	case seriesprovider.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case seriesprovider.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case seriesprovider.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case seriesprovider.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case seriesprovider.FieldArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case seriesprovider.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case seriesprovider.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case seriesprovider.FieldGenre:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenre(v)
		return nil
	case seriesprovider.FieldFetchDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFetchDate(v)
		return nil
	case seriesprovider.FieldChapterCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterCount(v)
		return nil
	case seriesprovider.FieldContinueAfterChapter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinueAfterChapter(v)
		return nil
	case seriesprovider.FieldIsTitle:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTitle(v)
		return nil
	case seriesprovider.FieldIsCover:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCover(v)
		return nil
	case seriesprovider.FieldIsUnknown:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUnknown(v)
		return nil
	case seriesprovider.FieldImportance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportance(v)
		return nil
	case seriesprovider.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case seriesprovider.FieldIsUninstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUninstalled(v)
		return nil
	case seriesprovider.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case seriesprovider.FieldChapters:
		v, ok := value.([]types.Chapter)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapters(v)
		return nil
	}
	return fmt.Errorf("unknown SeriesProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeriesProviderMutation) AddedFields() []string {
	var fields []string
	if m.addsuwayomi_id != nil {
		fields = append(fields, seriesprovider.FieldSuwayomiID)
	}
	if m.addchapter_count != nil {
		fields = append(fields, seriesprovider.FieldChapterCount)
	}
	if m.addcontinue_after_chapter != nil {
		fields = append(fields, seriesprovider.FieldContinueAfterChapter)
	}
	if m.addimportance != nil {
		fields = append(fields, seriesprovider.FieldImportance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeriesProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case seriesprovider.FieldSuwayomiID:
		return m.AddedSuwayomiID()
	case seriesprovider.FieldChapterCount:
		return m.AddedChapterCount()
	case seriesprovider.FieldContinueAfterChapter:
		return m.AddedContinueAfterChapter()
	case seriesprovider.FieldImportance:
		return m.AddedImportance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case seriesprovider.FieldSuwayomiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuwayomiID(v)
		return nil
	case seriesprovider.FieldChapterCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterCount(v)
		return nil
	case seriesprovider.FieldContinueAfterChapter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContinueAfterChapter(v)
		return nil
	case seriesprovider.FieldImportance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImportance(v)
		return nil
	}
	return fmt.Errorf("unknown SeriesProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeriesProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(seriesprovider.FieldURL) {
		fields = append(fields, seriesprovider.FieldURL)
	}
	if m.FieldCleared(seriesprovider.FieldThumbnailURL) {
		fields = append(fields, seriesprovider.FieldThumbnailURL)
	}
	if m.FieldCleared(seriesprovider.FieldArtist) {
		fields = append(fields, seriesprovider.FieldArtist)
	}
	if m.FieldCleared(seriesprovider.FieldAuthor) {
		fields = append(fields, seriesprovider.FieldAuthor)
	}
	if m.FieldCleared(seriesprovider.FieldDescription) {
		fields = append(fields, seriesprovider.FieldDescription)
	}
	if m.FieldCleared(seriesprovider.FieldGenre) {
		fields = append(fields, seriesprovider.FieldGenre)
	}
	if m.FieldCleared(seriesprovider.FieldFetchDate) {
		fields = append(fields, seriesprovider.FieldFetchDate)
	}
	if m.FieldCleared(seriesprovider.FieldChapterCount) {
		fields = append(fields, seriesprovider.FieldChapterCount)
	}
	if m.FieldCleared(seriesprovider.FieldContinueAfterChapter) {
		fields = append(fields, seriesprovider.FieldContinueAfterChapter)
	}
	if m.FieldCleared(seriesprovider.FieldChapters) {
		fields = append(fields, seriesprovider.FieldChapters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeriesProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeriesProviderMutation) ClearField(name string) error {
	switch name {
	case seriesprovider.FieldURL:
		m.ClearURL()
		return nil
	case seriesprovider.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case seriesprovider.FieldArtist:
		m.ClearArtist()
		return nil
	case seriesprovider.FieldAuthor:
		m.ClearAuthor()
		return nil
	case seriesprovider.FieldDescription:
		m.ClearDescription()
		return nil
	case seriesprovider.FieldGenre:
		m.ClearGenre()
		return nil
	case seriesprovider.FieldFetchDate:
		m.ClearFetchDate()
		return nil
	case seriesprovider.FieldChapterCount:
		m.ClearChapterCount()
		return nil
	case seriesprovider.FieldContinueAfterChapter:
		m.ClearContinueAfterChapter()
		return nil
	case seriesprovider.FieldChapters:
		m.ClearChapters()
		return nil
	}
	return fmt.Errorf("unknown SeriesProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeriesProviderMutation) ResetField(name string) error {
	switch name {
	case seriesprovider.FieldSeriesID:
		m.ResetSeriesID()
		return nil
	case seriesprovider.FieldSuwayomiID:
		m.ResetSuwayomiID()
		return nil
	case seriesprovider.FieldProvider:
		m.ResetProvider()
		return nil
	case seriesprovider.FieldScanlator:
		m.ResetScanlator()
		return nil
	case seriesprovider.FieldURL:
		m.ResetURL()
		return nil
	case seriesprovider.FieldTitle:
		m.ResetTitle()
		return nil
	case seriesprovider.FieldLanguage:
		m.ResetLanguage()
		return nil
	case seriesprovider.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case seriesprovider.FieldArtist:
		m.ResetArtist()
		return nil
	case seriesprovider.FieldAuthor:
		m.ResetAuthor()
		return nil
	case seriesprovider.FieldDescription:
		m.ResetDescription()
		return nil
	case seriesprovider.FieldGenre:
		m.ResetGenre()
		return nil
	case seriesprovider.FieldFetchDate:
		m.ResetFetchDate()
		return nil
	case seriesprovider.FieldChapterCount:
		m.ResetChapterCount()
		return nil
	case seriesprovider.FieldContinueAfterChapter:
		m.ResetContinueAfterChapter()
		return nil
	case seriesprovider.FieldIsTitle:
		m.ResetIsTitle()
		return nil
	case seriesprovider.FieldIsCover:
		m.ResetIsCover()
		return nil
	case seriesprovider.FieldIsUnknown:
		m.ResetIsUnknown()
		return nil
	case seriesprovider.FieldImportance:
		m.ResetImportance()
		return nil
	case seriesprovider.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case seriesprovider.FieldIsUninstalled:
		m.ResetIsUninstalled()
		return nil
	case seriesprovider.FieldStatus:
		m.ResetStatus()
		return nil
	case seriesprovider.FieldChapters:
		m.ResetChapters()
		return nil
	}
	return fmt.Errorf("unknown SeriesProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeriesProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.series != nil {
		edges = append(edges, seriesprovider.EdgeSeries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeriesProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seriesprovider.EdgeSeries:
		if id := m.series; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeriesProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeriesProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeriesProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedseries {
		edges = append(edges, seriesprovider.EdgeSeries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeriesProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case seriesprovider.EdgeSeries:
		return m.clearedseries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeriesProviderMutation) ClearEdge(name string) error {
	switch name {
	case seriesprovider.EdgeSeries:
		m.ClearSeries()
		return nil
	}
	return fmt.Errorf("unknown SeriesProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeriesProviderMutation) ResetEdge(name string) error {
	switch name {
	case seriesprovider.EdgeSeries:
		m.ResetSeries()
		return nil
	}
	return fmt.Errorf("unknown SeriesProvider edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id string) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SourceEventMutation represents an operation that mutates the SourceEvent nodes in the graph.
type SourceEventMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	source_id      *string
	source_name    *string
	language       *string
	event_type     *string
	status         *string
	duration_ms    *int64
	addduration_ms *int64
	error_message  *string
	error_category *string
	items_count    *int
	additems_count *int
	metadata       *map[string]string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*SourceEvent, error)
	predicates     []predicate.SourceEvent
}

var _ ent.Mutation = (*SourceEventMutation)(nil)

// sourceeventOption allows management of the mutation configuration using functional options.
type sourceeventOption func(*SourceEventMutation)

// newSourceEventMutation creates new mutation for the SourceEvent entity.
func newSourceEventMutation(c config, op Op, opts ...sourceeventOption) *SourceEventMutation {
	m := &SourceEventMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceEventID sets the ID field of the mutation.
func withSourceEventID(id uuid.UUID) sourceeventOption {
	return func(m *SourceEventMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceEvent
		)
		m.oldValue = func(ctx context.Context) (*SourceEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceEvent sets the old SourceEvent of the mutation.
func withSourceEvent(node *SourceEvent) sourceeventOption {
	return func(m *SourceEventMutation) {
		m.oldValue = func(context.Context) (*SourceEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceEvent entities.
func (m *SourceEventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceEventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceEventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *SourceEventMutation) SetSourceID(s string) {
	m.source_id = &s
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *SourceEventMutation) SourceID() (r string, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldSourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *SourceEventMutation) ResetSourceID() {
	m.source_id = nil
}

// SetSourceName sets the "source_name" field.
func (m *SourceEventMutation) SetSourceName(s string) {
	m.source_name = &s
}

// SourceName returns the value of the "source_name" field in the mutation.
func (m *SourceEventMutation) SourceName() (r string, exists bool) {
	v := m.source_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceName returns the old "source_name" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldSourceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceName: %w", err)
	}
	return oldValue.SourceName, nil
}

// ResetSourceName resets all changes to the "source_name" field.
func (m *SourceEventMutation) ResetSourceName() {
	m.source_name = nil
}

// SetLanguage sets the "language" field.
func (m *SourceEventMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *SourceEventMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *SourceEventMutation) ResetLanguage() {
	m.language = nil
}

// SetEventType sets the "event_type" field.
func (m *SourceEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *SourceEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *SourceEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetStatus sets the "status" field.
func (m *SourceEventMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SourceEventMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SourceEventMutation) ResetStatus() {
	m.status = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *SourceEventMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *SourceEventMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *SourceEventMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *SourceEventMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *SourceEventMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *SourceEventMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *SourceEventMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *SourceEventMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[sourceevent.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *SourceEventMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[sourceevent.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *SourceEventMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, sourceevent.FieldErrorMessage)
}

// SetErrorCategory sets the "error_category" field.
func (m *SourceEventMutation) SetErrorCategory(s string) {
	m.error_category = &s
}

// ErrorCategory returns the value of the "error_category" field in the mutation.
func (m *SourceEventMutation) ErrorCategory() (r string, exists bool) {
	v := m.error_category
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCategory returns the old "error_category" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldErrorCategory(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCategory: %w", err)
	}
	return oldValue.ErrorCategory, nil
}

// ClearErrorCategory clears the value of the "error_category" field.
func (m *SourceEventMutation) ClearErrorCategory() {
	m.error_category = nil
	m.clearedFields[sourceevent.FieldErrorCategory] = struct{}{}
}

// ErrorCategoryCleared returns if the "error_category" field was cleared in this mutation.
func (m *SourceEventMutation) ErrorCategoryCleared() bool {
	_, ok := m.clearedFields[sourceevent.FieldErrorCategory]
	return ok
}

// ResetErrorCategory resets all changes to the "error_category" field.
func (m *SourceEventMutation) ResetErrorCategory() {
	m.error_category = nil
	delete(m.clearedFields, sourceevent.FieldErrorCategory)
}

// SetItemsCount sets the "items_count" field.
func (m *SourceEventMutation) SetItemsCount(i int) {
	m.items_count = &i
	m.additems_count = nil
}

// ItemsCount returns the value of the "items_count" field in the mutation.
func (m *SourceEventMutation) ItemsCount() (r int, exists bool) {
	v := m.items_count
	if v == nil {
		return
	}
	return *v, true
}

// OldItemsCount returns the old "items_count" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldItemsCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemsCount: %w", err)
	}
	return oldValue.ItemsCount, nil
}

// AddItemsCount adds i to the "items_count" field.
func (m *SourceEventMutation) AddItemsCount(i int) {
	if m.additems_count != nil {
		*m.additems_count += i
	} else {
		m.additems_count = &i
	}
}

// AddedItemsCount returns the value that was added to the "items_count" field in this mutation.
func (m *SourceEventMutation) AddedItemsCount() (r int, exists bool) {
	v := m.additems_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearItemsCount clears the value of the "items_count" field.
func (m *SourceEventMutation) ClearItemsCount() {
	m.items_count = nil
	m.additems_count = nil
	m.clearedFields[sourceevent.FieldItemsCount] = struct{}{}
}

// ItemsCountCleared returns if the "items_count" field was cleared in this mutation.
func (m *SourceEventMutation) ItemsCountCleared() bool {
	_, ok := m.clearedFields[sourceevent.FieldItemsCount]
	return ok
}

// ResetItemsCount resets all changes to the "items_count" field.
func (m *SourceEventMutation) ResetItemsCount() {
	m.items_count = nil
	m.additems_count = nil
	delete(m.clearedFields, sourceevent.FieldItemsCount)
}

// SetMetadata sets the "metadata" field.
func (m *SourceEventMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SourceEventMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SourceEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[sourceevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SourceEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[sourceevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SourceEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, sourceevent.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *SourceEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SourceEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SourceEvent entity.
// If the SourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SourceEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the SourceEventMutation builder.
func (m *SourceEventMutation) Where(ps ...predicate.SourceEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceEvent).
func (m *SourceEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.source_id != nil {
		fields = append(fields, sourceevent.FieldSourceID)
	}
	if m.source_name != nil {
		fields = append(fields, sourceevent.FieldSourceName)
	}
	if m.language != nil {
		fields = append(fields, sourceevent.FieldLanguage)
	}
	if m.event_type != nil {
		fields = append(fields, sourceevent.FieldEventType)
	}
	if m.status != nil {
		fields = append(fields, sourceevent.FieldStatus)
	}
	if m.duration_ms != nil {
		fields = append(fields, sourceevent.FieldDurationMs)
	}
	if m.error_message != nil {
		fields = append(fields, sourceevent.FieldErrorMessage)
	}
	if m.error_category != nil {
		fields = append(fields, sourceevent.FieldErrorCategory)
	}
	if m.items_count != nil {
		fields = append(fields, sourceevent.FieldItemsCount)
	}
	if m.metadata != nil {
		fields = append(fields, sourceevent.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, sourceevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourceevent.FieldSourceID:
		return m.SourceID()
	case sourceevent.FieldSourceName:
		return m.SourceName()
	case sourceevent.FieldLanguage:
		return m.Language()
	case sourceevent.FieldEventType:
		return m.EventType()
	case sourceevent.FieldStatus:
		return m.Status()
	case sourceevent.FieldDurationMs:
		return m.DurationMs()
	case sourceevent.FieldErrorMessage:
		return m.ErrorMessage()
	case sourceevent.FieldErrorCategory:
		return m.ErrorCategory()
	case sourceevent.FieldItemsCount:
		return m.ItemsCount()
	case sourceevent.FieldMetadata:
		return m.Metadata()
	case sourceevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourceevent.FieldSourceID:
		return m.OldSourceID(ctx)
	case sourceevent.FieldSourceName:
		return m.OldSourceName(ctx)
	case sourceevent.FieldLanguage:
		return m.OldLanguage(ctx)
	case sourceevent.FieldEventType:
		return m.OldEventType(ctx)
	case sourceevent.FieldStatus:
		return m.OldStatus(ctx)
	case sourceevent.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case sourceevent.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case sourceevent.FieldErrorCategory:
		return m.OldErrorCategory(ctx)
	case sourceevent.FieldItemsCount:
		return m.OldItemsCount(ctx)
	case sourceevent.FieldMetadata:
		return m.OldMetadata(ctx)
	case sourceevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SourceEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourceevent.FieldSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case sourceevent.FieldSourceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceName(v)
		return nil
	case sourceevent.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case sourceevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case sourceevent.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sourceevent.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case sourceevent.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case sourceevent.FieldErrorCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCategory(v)
		return nil
	case sourceevent.FieldItemsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemsCount(v)
		return nil
	case sourceevent.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case sourceevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SourceEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceEventMutation) AddedFields() []string {
	var fields []string
	if m.addduration_ms != nil {
		fields = append(fields, sourceevent.FieldDurationMs)
	}
	if m.additems_count != nil {
		fields = append(fields, sourceevent.FieldItemsCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sourceevent.FieldDurationMs:
		return m.AddedDurationMs()
	case sourceevent.FieldItemsCount:
		return m.AddedItemsCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sourceevent.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	case sourceevent.FieldItemsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemsCount(v)
		return nil
	}
	return fmt.Errorf("unknown SourceEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourceevent.FieldErrorMessage) {
		fields = append(fields, sourceevent.FieldErrorMessage)
	}
	if m.FieldCleared(sourceevent.FieldErrorCategory) {
		fields = append(fields, sourceevent.FieldErrorCategory)
	}
	if m.FieldCleared(sourceevent.FieldItemsCount) {
		fields = append(fields, sourceevent.FieldItemsCount)
	}
	if m.FieldCleared(sourceevent.FieldMetadata) {
		fields = append(fields, sourceevent.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceEventMutation) ClearField(name string) error {
	switch name {
	case sourceevent.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case sourceevent.FieldErrorCategory:
		m.ClearErrorCategory()
		return nil
	case sourceevent.FieldItemsCount:
		m.ClearItemsCount()
		return nil
	case sourceevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown SourceEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceEventMutation) ResetField(name string) error {
	switch name {
	case sourceevent.FieldSourceID:
		m.ResetSourceID()
		return nil
	case sourceevent.FieldSourceName:
		m.ResetSourceName()
		return nil
	case sourceevent.FieldLanguage:
		m.ResetLanguage()
		return nil
	case sourceevent.FieldEventType:
		m.ResetEventType()
		return nil
	case sourceevent.FieldStatus:
		m.ResetStatus()
		return nil
	case sourceevent.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case sourceevent.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case sourceevent.FieldErrorCategory:
		m.ResetErrorCategory()
		return nil
	case sourceevent.FieldItemsCount:
		m.ResetItemsCount()
		return nil
	case sourceevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	case sourceevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SourceEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SourceEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SourceEvent edge %s", name)
}
