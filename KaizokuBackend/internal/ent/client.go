// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/technobecet/kaizoku-go/internal/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/technobecet/kaizoku-go/internal/ent/downloadqueueitem"
	"github.com/technobecet/kaizoku-go/internal/ent/etagcache"
	"github.com/technobecet/kaizoku-go/internal/ent/importentry"
	"github.com/technobecet/kaizoku-go/internal/ent/latestseries"
	"github.com/technobecet/kaizoku-go/internal/ent/providerstorage"
	"github.com/technobecet/kaizoku-go/internal/ent/series"
	"github.com/technobecet/kaizoku-go/internal/ent/seriesprovider"
	"github.com/technobecet/kaizoku-go/internal/ent/setting"
	"github.com/technobecet/kaizoku-go/internal/ent/sourceevent"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// DownloadQueueItem is the client for interacting with the DownloadQueueItem builders.
	DownloadQueueItem *DownloadQueueItemClient
	// EtagCache is the client for interacting with the EtagCache builders.
	EtagCache *EtagCacheClient
	// ImportEntry is the client for interacting with the ImportEntry builders.
	ImportEntry *ImportEntryClient
	// LatestSeries is the client for interacting with the LatestSeries builders.
	LatestSeries *LatestSeriesClient
	// ProviderStorage is the client for interacting with the ProviderStorage builders.
	ProviderStorage *ProviderStorageClient
	// Series is the client for interacting with the Series builders.
	Series *SeriesClient
	// SeriesProvider is the client for interacting with the SeriesProvider builders.
	SeriesProvider *SeriesProviderClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// SourceEvent is the client for interacting with the SourceEvent builders.
	SourceEvent *SourceEventClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.DownloadQueueItem = NewDownloadQueueItemClient(c.config)
	c.EtagCache = NewEtagCacheClient(c.config)
	c.ImportEntry = NewImportEntryClient(c.config)
	c.LatestSeries = NewLatestSeriesClient(c.config)
	c.ProviderStorage = NewProviderStorageClient(c.config)
	c.Series = NewSeriesClient(c.config)
	c.SeriesProvider = NewSeriesProviderClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.SourceEvent = NewSourceEventClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		DownloadQueueItem: NewDownloadQueueItemClient(cfg),
		EtagCache:         NewEtagCacheClient(cfg),
		ImportEntry:       NewImportEntryClient(cfg),
		LatestSeries:      NewLatestSeriesClient(cfg),
		ProviderStorage:   NewProviderStorageClient(cfg),
		Series:            NewSeriesClient(cfg),
		SeriesProvider:    NewSeriesProviderClient(cfg),
		Setting:           NewSettingClient(cfg),
		SourceEvent:       NewSourceEventClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		DownloadQueueItem: NewDownloadQueueItemClient(cfg),
		EtagCache:         NewEtagCacheClient(cfg),
		ImportEntry:       NewImportEntryClient(cfg),
		LatestSeries:      NewLatestSeriesClient(cfg),
		ProviderStorage:   NewProviderStorageClient(cfg),
		Series:            NewSeriesClient(cfg),
		SeriesProvider:    NewSeriesProviderClient(cfg),
		Setting:           NewSettingClient(cfg),
		SourceEvent:       NewSourceEventClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		DownloadQueueItem.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.DownloadQueueItem, c.EtagCache, c.ImportEntry, c.LatestSeries,
		c.ProviderStorage, c.Series, c.SeriesProvider, c.Setting, c.SourceEvent,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.DownloadQueueItem, c.EtagCache, c.ImportEntry, c.LatestSeries,
		c.ProviderStorage, c.Series, c.SeriesProvider, c.Setting, c.SourceEvent,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DownloadQueueItemMutation:
		return c.DownloadQueueItem.mutate(ctx, m)
	case *EtagCacheMutation:
		return c.EtagCache.mutate(ctx, m)
	case *ImportEntryMutation:
		return c.ImportEntry.mutate(ctx, m)
	case *LatestSeriesMutation:
		return c.LatestSeries.mutate(ctx, m)
	case *ProviderStorageMutation:
		return c.ProviderStorage.mutate(ctx, m)
	case *SeriesMutation:
		return c.Series.mutate(ctx, m)
	case *SeriesProviderMutation:
		return c.SeriesProvider.mutate(ctx, m)
	case *SettingMutation:
		return c.Setting.mutate(ctx, m)
	case *SourceEventMutation:
		return c.SourceEvent.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// DownloadQueueItemClient is a client for the DownloadQueueItem schema.
type DownloadQueueItemClient struct {
	config
}

// NewDownloadQueueItemClient returns a client for the DownloadQueueItem from the given config.
func NewDownloadQueueItemClient(c config) *DownloadQueueItemClient {
	return &DownloadQueueItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `downloadqueueitem.Hooks(f(g(h())))`.
func (c *DownloadQueueItemClient) Use(hooks ...Hook) {
	c.hooks.DownloadQueueItem = append(c.hooks.DownloadQueueItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `downloadqueueitem.Intercept(f(g(h())))`.
func (c *DownloadQueueItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.DownloadQueueItem = append(c.inters.DownloadQueueItem, interceptors...)
}

// Create returns a builder for creating a DownloadQueueItem entity.
func (c *DownloadQueueItemClient) Create() *DownloadQueueItemCreate {
	mutation := newDownloadQueueItemMutation(c.config, OpCreate)
	return &DownloadQueueItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DownloadQueueItem entities.
func (c *DownloadQueueItemClient) CreateBulk(builders ...*DownloadQueueItemCreate) *DownloadQueueItemCreateBulk {
	return &DownloadQueueItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DownloadQueueItemClient) MapCreateBulk(slice any, setFunc func(*DownloadQueueItemCreate, int)) *DownloadQueueItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DownloadQueueItemCreateBulk{err: fmt.Errorf("calling to DownloadQueueItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DownloadQueueItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DownloadQueueItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DownloadQueueItem.
func (c *DownloadQueueItemClient) Update() *DownloadQueueItemUpdate {
	mutation := newDownloadQueueItemMutation(c.config, OpUpdate)
	return &DownloadQueueItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DownloadQueueItemClient) UpdateOne(_m *DownloadQueueItem) *DownloadQueueItemUpdateOne {
	mutation := newDownloadQueueItemMutation(c.config, OpUpdateOne, withDownloadQueueItem(_m))
	return &DownloadQueueItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DownloadQueueItemClient) UpdateOneID(id uuid.UUID) *DownloadQueueItemUpdateOne {
	mutation := newDownloadQueueItemMutation(c.config, OpUpdateOne, withDownloadQueueItemID(id))
	return &DownloadQueueItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DownloadQueueItem.
func (c *DownloadQueueItemClient) Delete() *DownloadQueueItemDelete {
	mutation := newDownloadQueueItemMutation(c.config, OpDelete)
	return &DownloadQueueItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DownloadQueueItemClient) DeleteOne(_m *DownloadQueueItem) *DownloadQueueItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DownloadQueueItemClient) DeleteOneID(id uuid.UUID) *DownloadQueueItemDeleteOne {
	builder := c.Delete().Where(downloadqueueitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DownloadQueueItemDeleteOne{builder}
}

// Query returns a query builder for DownloadQueueItem.
func (c *DownloadQueueItemClient) Query() *DownloadQueueItemQuery {
	return &DownloadQueueItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDownloadQueueItem},
		inters: c.Interceptors(),
	}
}

// Get returns a DownloadQueueItem entity by its id.
func (c *DownloadQueueItemClient) Get(ctx context.Context, id uuid.UUID) (*DownloadQueueItem, error) {
	return c.Query().Where(downloadqueueitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DownloadQueueItemClient) GetX(ctx context.Context, id uuid.UUID) *DownloadQueueItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DownloadQueueItemClient) Hooks() []Hook {
	return c.hooks.DownloadQueueItem
}

// Interceptors returns the client interceptors.
func (c *DownloadQueueItemClient) Interceptors() []Interceptor {
	return c.inters.DownloadQueueItem
}

func (c *DownloadQueueItemClient) mutate(ctx context.Context, m *DownloadQueueItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DownloadQueueItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DownloadQueueItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DownloadQueueItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DownloadQueueItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DownloadQueueItem mutation op: %q", m.Op())
	}
}

// EtagCacheClient is a client for the EtagCache schema.
type EtagCacheClient struct {
	config
}

// NewEtagCacheClient returns a client for the EtagCache from the given config.
func NewEtagCacheClient(c config) *EtagCacheClient {
	return &EtagCacheClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `etagcache.Hooks(f(g(h())))`.
func (c *EtagCacheClient) Use(hooks ...Hook) {
	c.hooks.EtagCache = append(c.hooks.EtagCache, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `etagcache.Intercept(f(g(h())))`.
func (c *EtagCacheClient) Intercept(interceptors ...Interceptor) {
	c.inters.EtagCache = append(c.inters.EtagCache, interceptors...)
}

// Create returns a builder for creating a EtagCache entity.
func (c *EtagCacheClient) Create() *EtagCacheCreate {
	mutation := newEtagCacheMutation(c.config, OpCreate)
	return &EtagCacheCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EtagCache entities.
func (c *EtagCacheClient) CreateBulk(builders ...*EtagCacheCreate) *EtagCacheCreateBulk {
	return &EtagCacheCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EtagCacheClient) MapCreateBulk(slice any, setFunc func(*EtagCacheCreate, int)) *EtagCacheCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EtagCacheCreateBulk{err: fmt.Errorf("calling to EtagCacheClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EtagCacheCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EtagCacheCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EtagCache.
func (c *EtagCacheClient) Update() *EtagCacheUpdate {
	mutation := newEtagCacheMutation(c.config, OpUpdate)
	return &EtagCacheUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EtagCacheClient) UpdateOne(_m *EtagCache) *EtagCacheUpdateOne {
	mutation := newEtagCacheMutation(c.config, OpUpdateOne, withEtagCache(_m))
	return &EtagCacheUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EtagCacheClient) UpdateOneID(id string) *EtagCacheUpdateOne {
	mutation := newEtagCacheMutation(c.config, OpUpdateOne, withEtagCacheID(id))
	return &EtagCacheUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EtagCache.
func (c *EtagCacheClient) Delete() *EtagCacheDelete {
	mutation := newEtagCacheMutation(c.config, OpDelete)
	return &EtagCacheDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EtagCacheClient) DeleteOne(_m *EtagCache) *EtagCacheDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EtagCacheClient) DeleteOneID(id string) *EtagCacheDeleteOne {
	builder := c.Delete().Where(etagcache.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EtagCacheDeleteOne{builder}
}

// Query returns a query builder for EtagCache.
func (c *EtagCacheClient) Query() *EtagCacheQuery {
	return &EtagCacheQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEtagCache},
		inters: c.Interceptors(),
	}
}

// Get returns a EtagCache entity by its id.
func (c *EtagCacheClient) Get(ctx context.Context, id string) (*EtagCache, error) {
	return c.Query().Where(etagcache.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EtagCacheClient) GetX(ctx context.Context, id string) *EtagCache {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EtagCacheClient) Hooks() []Hook {
	return c.hooks.EtagCache
}

// Interceptors returns the client interceptors.
func (c *EtagCacheClient) Interceptors() []Interceptor {
	return c.inters.EtagCache
}

func (c *EtagCacheClient) mutate(ctx context.Context, m *EtagCacheMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EtagCacheCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EtagCacheUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EtagCacheUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EtagCacheDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EtagCache mutation op: %q", m.Op())
	}
}

// ImportEntryClient is a client for the ImportEntry schema.
type ImportEntryClient struct {
	config
}

// NewImportEntryClient returns a client for the ImportEntry from the given config.
func NewImportEntryClient(c config) *ImportEntryClient {
	return &ImportEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `importentry.Hooks(f(g(h())))`.
func (c *ImportEntryClient) Use(hooks ...Hook) {
	c.hooks.ImportEntry = append(c.hooks.ImportEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `importentry.Intercept(f(g(h())))`.
func (c *ImportEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImportEntry = append(c.inters.ImportEntry, interceptors...)
}

// Create returns a builder for creating a ImportEntry entity.
func (c *ImportEntryClient) Create() *ImportEntryCreate {
	mutation := newImportEntryMutation(c.config, OpCreate)
	return &ImportEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImportEntry entities.
func (c *ImportEntryClient) CreateBulk(builders ...*ImportEntryCreate) *ImportEntryCreateBulk {
	return &ImportEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImportEntryClient) MapCreateBulk(slice any, setFunc func(*ImportEntryCreate, int)) *ImportEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImportEntryCreateBulk{err: fmt.Errorf("calling to ImportEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImportEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImportEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImportEntry.
func (c *ImportEntryClient) Update() *ImportEntryUpdate {
	mutation := newImportEntryMutation(c.config, OpUpdate)
	return &ImportEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImportEntryClient) UpdateOne(_m *ImportEntry) *ImportEntryUpdateOne {
	mutation := newImportEntryMutation(c.config, OpUpdateOne, withImportEntry(_m))
	return &ImportEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImportEntryClient) UpdateOneID(id string) *ImportEntryUpdateOne {
	mutation := newImportEntryMutation(c.config, OpUpdateOne, withImportEntryID(id))
	return &ImportEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImportEntry.
func (c *ImportEntryClient) Delete() *ImportEntryDelete {
	mutation := newImportEntryMutation(c.config, OpDelete)
	return &ImportEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImportEntryClient) DeleteOne(_m *ImportEntry) *ImportEntryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImportEntryClient) DeleteOneID(id string) *ImportEntryDeleteOne {
	builder := c.Delete().Where(importentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImportEntryDeleteOne{builder}
}

// Query returns a query builder for ImportEntry.
func (c *ImportEntryClient) Query() *ImportEntryQuery {
	return &ImportEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImportEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a ImportEntry entity by its id.
func (c *ImportEntryClient) Get(ctx context.Context, id string) (*ImportEntry, error) {
	return c.Query().Where(importentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImportEntryClient) GetX(ctx context.Context, id string) *ImportEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ImportEntryClient) Hooks() []Hook {
	return c.hooks.ImportEntry
}

// Interceptors returns the client interceptors.
func (c *ImportEntryClient) Interceptors() []Interceptor {
	return c.inters.ImportEntry
}

func (c *ImportEntryClient) mutate(ctx context.Context, m *ImportEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImportEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImportEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImportEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImportEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ImportEntry mutation op: %q", m.Op())
	}
}

// LatestSeriesClient is a client for the LatestSeries schema.
type LatestSeriesClient struct {
	config
}

// NewLatestSeriesClient returns a client for the LatestSeries from the given config.
func NewLatestSeriesClient(c config) *LatestSeriesClient {
	return &LatestSeriesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `latestseries.Hooks(f(g(h())))`.
func (c *LatestSeriesClient) Use(hooks ...Hook) {
	c.hooks.LatestSeries = append(c.hooks.LatestSeries, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `latestseries.Intercept(f(g(h())))`.
func (c *LatestSeriesClient) Intercept(interceptors ...Interceptor) {
	c.inters.LatestSeries = append(c.inters.LatestSeries, interceptors...)
}

// Create returns a builder for creating a LatestSeries entity.
func (c *LatestSeriesClient) Create() *LatestSeriesCreate {
	mutation := newLatestSeriesMutation(c.config, OpCreate)
	return &LatestSeriesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LatestSeries entities.
func (c *LatestSeriesClient) CreateBulk(builders ...*LatestSeriesCreate) *LatestSeriesCreateBulk {
	return &LatestSeriesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LatestSeriesClient) MapCreateBulk(slice any, setFunc func(*LatestSeriesCreate, int)) *LatestSeriesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LatestSeriesCreateBulk{err: fmt.Errorf("calling to LatestSeriesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LatestSeriesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LatestSeriesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LatestSeries.
func (c *LatestSeriesClient) Update() *LatestSeriesUpdate {
	mutation := newLatestSeriesMutation(c.config, OpUpdate)
	return &LatestSeriesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LatestSeriesClient) UpdateOne(_m *LatestSeries) *LatestSeriesUpdateOne {
	mutation := newLatestSeriesMutation(c.config, OpUpdateOne, withLatestSeries(_m))
	return &LatestSeriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LatestSeriesClient) UpdateOneID(id int) *LatestSeriesUpdateOne {
	mutation := newLatestSeriesMutation(c.config, OpUpdateOne, withLatestSeriesID(id))
	return &LatestSeriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LatestSeries.
func (c *LatestSeriesClient) Delete() *LatestSeriesDelete {
	mutation := newLatestSeriesMutation(c.config, OpDelete)
	return &LatestSeriesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LatestSeriesClient) DeleteOne(_m *LatestSeries) *LatestSeriesDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LatestSeriesClient) DeleteOneID(id int) *LatestSeriesDeleteOne {
	builder := c.Delete().Where(latestseries.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LatestSeriesDeleteOne{builder}
}

// Query returns a query builder for LatestSeries.
func (c *LatestSeriesClient) Query() *LatestSeriesQuery {
	return &LatestSeriesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLatestSeries},
		inters: c.Interceptors(),
	}
}

// Get returns a LatestSeries entity by its id.
func (c *LatestSeriesClient) Get(ctx context.Context, id int) (*LatestSeries, error) {
	return c.Query().Where(latestseries.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LatestSeriesClient) GetX(ctx context.Context, id int) *LatestSeries {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySeries queries the series edge of a LatestSeries.
func (c *LatestSeriesClient) QuerySeries(_m *LatestSeries) *SeriesQuery {
	query := (&SeriesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(latestseries.Table, latestseries.FieldID, id),
			sqlgraph.To(series.Table, series.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, latestseries.SeriesTable, latestseries.SeriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LatestSeriesClient) Hooks() []Hook {
	return c.hooks.LatestSeries
}

// Interceptors returns the client interceptors.
func (c *LatestSeriesClient) Interceptors() []Interceptor {
	return c.inters.LatestSeries
}

func (c *LatestSeriesClient) mutate(ctx context.Context, m *LatestSeriesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LatestSeriesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LatestSeriesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LatestSeriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LatestSeriesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LatestSeries mutation op: %q", m.Op())
	}
}

// ProviderStorageClient is a client for the ProviderStorage schema.
type ProviderStorageClient struct {
	config
}

// NewProviderStorageClient returns a client for the ProviderStorage from the given config.
func NewProviderStorageClient(c config) *ProviderStorageClient {
	return &ProviderStorageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `providerstorage.Hooks(f(g(h())))`.
func (c *ProviderStorageClient) Use(hooks ...Hook) {
	c.hooks.ProviderStorage = append(c.hooks.ProviderStorage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `providerstorage.Intercept(f(g(h())))`.
func (c *ProviderStorageClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProviderStorage = append(c.inters.ProviderStorage, interceptors...)
}

// Create returns a builder for creating a ProviderStorage entity.
func (c *ProviderStorageClient) Create() *ProviderStorageCreate {
	mutation := newProviderStorageMutation(c.config, OpCreate)
	return &ProviderStorageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProviderStorage entities.
func (c *ProviderStorageClient) CreateBulk(builders ...*ProviderStorageCreate) *ProviderStorageCreateBulk {
	return &ProviderStorageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProviderStorageClient) MapCreateBulk(slice any, setFunc func(*ProviderStorageCreate, int)) *ProviderStorageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProviderStorageCreateBulk{err: fmt.Errorf("calling to ProviderStorageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProviderStorageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProviderStorageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProviderStorage.
func (c *ProviderStorageClient) Update() *ProviderStorageUpdate {
	mutation := newProviderStorageMutation(c.config, OpUpdate)
	return &ProviderStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProviderStorageClient) UpdateOne(_m *ProviderStorage) *ProviderStorageUpdateOne {
	mutation := newProviderStorageMutation(c.config, OpUpdateOne, withProviderStorage(_m))
	return &ProviderStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProviderStorageClient) UpdateOneID(id uuid.UUID) *ProviderStorageUpdateOne {
	mutation := newProviderStorageMutation(c.config, OpUpdateOne, withProviderStorageID(id))
	return &ProviderStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProviderStorage.
func (c *ProviderStorageClient) Delete() *ProviderStorageDelete {
	mutation := newProviderStorageMutation(c.config, OpDelete)
	return &ProviderStorageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProviderStorageClient) DeleteOne(_m *ProviderStorage) *ProviderStorageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProviderStorageClient) DeleteOneID(id uuid.UUID) *ProviderStorageDeleteOne {
	builder := c.Delete().Where(providerstorage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProviderStorageDeleteOne{builder}
}

// Query returns a query builder for ProviderStorage.
func (c *ProviderStorageClient) Query() *ProviderStorageQuery {
	return &ProviderStorageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProviderStorage},
		inters: c.Interceptors(),
	}
}

// Get returns a ProviderStorage entity by its id.
func (c *ProviderStorageClient) Get(ctx context.Context, id uuid.UUID) (*ProviderStorage, error) {
	return c.Query().Where(providerstorage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProviderStorageClient) GetX(ctx context.Context, id uuid.UUID) *ProviderStorage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProviderStorageClient) Hooks() []Hook {
	return c.hooks.ProviderStorage
}

// Interceptors returns the client interceptors.
func (c *ProviderStorageClient) Interceptors() []Interceptor {
	return c.inters.ProviderStorage
}

func (c *ProviderStorageClient) mutate(ctx context.Context, m *ProviderStorageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProviderStorageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProviderStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProviderStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProviderStorageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProviderStorage mutation op: %q", m.Op())
	}
}

// SeriesClient is a client for the Series schema.
type SeriesClient struct {
	config
}

// NewSeriesClient returns a client for the Series from the given config.
func NewSeriesClient(c config) *SeriesClient {
	return &SeriesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `series.Hooks(f(g(h())))`.
func (c *SeriesClient) Use(hooks ...Hook) {
	c.hooks.Series = append(c.hooks.Series, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `series.Intercept(f(g(h())))`.
func (c *SeriesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Series = append(c.inters.Series, interceptors...)
}

// Create returns a builder for creating a Series entity.
func (c *SeriesClient) Create() *SeriesCreate {
	mutation := newSeriesMutation(c.config, OpCreate)
	return &SeriesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Series entities.
func (c *SeriesClient) CreateBulk(builders ...*SeriesCreate) *SeriesCreateBulk {
	return &SeriesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SeriesClient) MapCreateBulk(slice any, setFunc func(*SeriesCreate, int)) *SeriesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SeriesCreateBulk{err: fmt.Errorf("calling to SeriesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SeriesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SeriesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Series.
func (c *SeriesClient) Update() *SeriesUpdate {
	mutation := newSeriesMutation(c.config, OpUpdate)
	return &SeriesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeriesClient) UpdateOne(_m *Series) *SeriesUpdateOne {
	mutation := newSeriesMutation(c.config, OpUpdateOne, withSeries(_m))
	return &SeriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeriesClient) UpdateOneID(id uuid.UUID) *SeriesUpdateOne {
	mutation := newSeriesMutation(c.config, OpUpdateOne, withSeriesID(id))
	return &SeriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Series.
func (c *SeriesClient) Delete() *SeriesDelete {
	mutation := newSeriesMutation(c.config, OpDelete)
	return &SeriesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeriesClient) DeleteOne(_m *Series) *SeriesDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeriesClient) DeleteOneID(id uuid.UUID) *SeriesDeleteOne {
	builder := c.Delete().Where(series.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeriesDeleteOne{builder}
}

// Query returns a query builder for Series.
func (c *SeriesClient) Query() *SeriesQuery {
	return &SeriesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeries},
		inters: c.Interceptors(),
	}
}

// Get returns a Series entity by its id.
func (c *SeriesClient) Get(ctx context.Context, id uuid.UUID) (*Series, error) {
	return c.Query().Where(series.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeriesClient) GetX(ctx context.Context, id uuid.UUID) *Series {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProviders queries the providers edge of a Series.
func (c *SeriesClient) QueryProviders(_m *Series) *SeriesProviderQuery {
	query := (&SeriesProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(series.Table, series.FieldID, id),
			sqlgraph.To(seriesprovider.Table, seriesprovider.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, series.ProvidersTable, series.ProvidersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLatestSeries queries the latest_series edge of a Series.
func (c *SeriesClient) QueryLatestSeries(_m *Series) *LatestSeriesQuery {
	query := (&LatestSeriesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(series.Table, series.FieldID, id),
			sqlgraph.To(latestseries.Table, latestseries.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, series.LatestSeriesTable, series.LatestSeriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeriesClient) Hooks() []Hook {
	return c.hooks.Series
}

// Interceptors returns the client interceptors.
func (c *SeriesClient) Interceptors() []Interceptor {
	return c.inters.Series
}

func (c *SeriesClient) mutate(ctx context.Context, m *SeriesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeriesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeriesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeriesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Series mutation op: %q", m.Op())
	}
}

// SeriesProviderClient is a client for the SeriesProvider schema.
type SeriesProviderClient struct {
	config
}

// NewSeriesProviderClient returns a client for the SeriesProvider from the given config.
func NewSeriesProviderClient(c config) *SeriesProviderClient {
	return &SeriesProviderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `seriesprovider.Hooks(f(g(h())))`.
func (c *SeriesProviderClient) Use(hooks ...Hook) {
	c.hooks.SeriesProvider = append(c.hooks.SeriesProvider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `seriesprovider.Intercept(f(g(h())))`.
func (c *SeriesProviderClient) Intercept(interceptors ...Interceptor) {
	c.inters.SeriesProvider = append(c.inters.SeriesProvider, interceptors...)
}

// Create returns a builder for creating a SeriesProvider entity.
func (c *SeriesProviderClient) Create() *SeriesProviderCreate {
	mutation := newSeriesProviderMutation(c.config, OpCreate)
	return &SeriesProviderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SeriesProvider entities.
func (c *SeriesProviderClient) CreateBulk(builders ...*SeriesProviderCreate) *SeriesProviderCreateBulk {
	return &SeriesProviderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SeriesProviderClient) MapCreateBulk(slice any, setFunc func(*SeriesProviderCreate, int)) *SeriesProviderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SeriesProviderCreateBulk{err: fmt.Errorf("calling to SeriesProviderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SeriesProviderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SeriesProviderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SeriesProvider.
func (c *SeriesProviderClient) Update() *SeriesProviderUpdate {
	mutation := newSeriesProviderMutation(c.config, OpUpdate)
	return &SeriesProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeriesProviderClient) UpdateOne(_m *SeriesProvider) *SeriesProviderUpdateOne {
	mutation := newSeriesProviderMutation(c.config, OpUpdateOne, withSeriesProvider(_m))
	return &SeriesProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeriesProviderClient) UpdateOneID(id uuid.UUID) *SeriesProviderUpdateOne {
	mutation := newSeriesProviderMutation(c.config, OpUpdateOne, withSeriesProviderID(id))
	return &SeriesProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SeriesProvider.
func (c *SeriesProviderClient) Delete() *SeriesProviderDelete {
	mutation := newSeriesProviderMutation(c.config, OpDelete)
	return &SeriesProviderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeriesProviderClient) DeleteOne(_m *SeriesProvider) *SeriesProviderDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeriesProviderClient) DeleteOneID(id uuid.UUID) *SeriesProviderDeleteOne {
	builder := c.Delete().Where(seriesprovider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeriesProviderDeleteOne{builder}
}

// Query returns a query builder for SeriesProvider.
func (c *SeriesProviderClient) Query() *SeriesProviderQuery {
	return &SeriesProviderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeriesProvider},
		inters: c.Interceptors(),
	}
}

// Get returns a SeriesProvider entity by its id.
func (c *SeriesProviderClient) Get(ctx context.Context, id uuid.UUID) (*SeriesProvider, error) {
	return c.Query().Where(seriesprovider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeriesProviderClient) GetX(ctx context.Context, id uuid.UUID) *SeriesProvider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySeries queries the series edge of a SeriesProvider.
func (c *SeriesProviderClient) QuerySeries(_m *SeriesProvider) *SeriesQuery {
	query := (&SeriesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seriesprovider.Table, seriesprovider.FieldID, id),
			sqlgraph.To(series.Table, series.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, seriesprovider.SeriesTable, seriesprovider.SeriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeriesProviderClient) Hooks() []Hook {
	return c.hooks.SeriesProvider
}

// Interceptors returns the client interceptors.
func (c *SeriesProviderClient) Interceptors() []Interceptor {
	return c.inters.SeriesProvider
}

func (c *SeriesProviderClient) mutate(ctx context.Context, m *SeriesProviderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeriesProviderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeriesProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeriesProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeriesProviderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SeriesProvider mutation op: %q", m.Op())
	}
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setting.Intercept(f(g(h())))`.
func (c *SettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Setting = append(c.inters.Setting, interceptors...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingClient) MapCreateBulk(slice any, setFunc func(*SettingCreate, int)) *SettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingCreateBulk{err: fmt.Errorf("calling to SettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(_m *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(_m))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id string) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(_m *Setting) *SettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id string) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id string) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id string) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	return c.hooks.Setting
}

// Interceptors returns the client interceptors.
func (c *SettingClient) Interceptors() []Interceptor {
	return c.inters.Setting
}

func (c *SettingClient) mutate(ctx context.Context, m *SettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Setting mutation op: %q", m.Op())
	}
}

// SourceEventClient is a client for the SourceEvent schema.
type SourceEventClient struct {
	config
}

// NewSourceEventClient returns a client for the SourceEvent from the given config.
func NewSourceEventClient(c config) *SourceEventClient {
	return &SourceEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourceevent.Hooks(f(g(h())))`.
func (c *SourceEventClient) Use(hooks ...Hook) {
	c.hooks.SourceEvent = append(c.hooks.SourceEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourceevent.Intercept(f(g(h())))`.
func (c *SourceEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceEvent = append(c.inters.SourceEvent, interceptors...)
}

// Create returns a builder for creating a SourceEvent entity.
func (c *SourceEventClient) Create() *SourceEventCreate {
	mutation := newSourceEventMutation(c.config, OpCreate)
	return &SourceEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceEvent entities.
func (c *SourceEventClient) CreateBulk(builders ...*SourceEventCreate) *SourceEventCreateBulk {
	return &SourceEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceEventClient) MapCreateBulk(slice any, setFunc func(*SourceEventCreate, int)) *SourceEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceEventCreateBulk{err: fmt.Errorf("calling to SourceEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceEvent.
func (c *SourceEventClient) Update() *SourceEventUpdate {
	mutation := newSourceEventMutation(c.config, OpUpdate)
	return &SourceEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceEventClient) UpdateOne(_m *SourceEvent) *SourceEventUpdateOne {
	mutation := newSourceEventMutation(c.config, OpUpdateOne, withSourceEvent(_m))
	return &SourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceEventClient) UpdateOneID(id uuid.UUID) *SourceEventUpdateOne {
	mutation := newSourceEventMutation(c.config, OpUpdateOne, withSourceEventID(id))
	return &SourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceEvent.
func (c *SourceEventClient) Delete() *SourceEventDelete {
	mutation := newSourceEventMutation(c.config, OpDelete)
	return &SourceEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceEventClient) DeleteOne(_m *SourceEvent) *SourceEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceEventClient) DeleteOneID(id uuid.UUID) *SourceEventDeleteOne {
	builder := c.Delete().Where(sourceevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceEventDeleteOne{builder}
}

// Query returns a query builder for SourceEvent.
func (c *SourceEventClient) Query() *SourceEventQuery {
	return &SourceEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceEvent entity by its id.
func (c *SourceEventClient) Get(ctx context.Context, id uuid.UUID) (*SourceEvent, error) {
	return c.Query().Where(sourceevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceEventClient) GetX(ctx context.Context, id uuid.UUID) *SourceEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SourceEventClient) Hooks() []Hook {
	return c.hooks.SourceEvent
}

// Interceptors returns the client interceptors.
func (c *SourceEventClient) Interceptors() []Interceptor {
	return c.inters.SourceEvent
}

func (c *SourceEventClient) mutate(ctx context.Context, m *SourceEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceEvent mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		DownloadQueueItem, EtagCache, ImportEntry, LatestSeries, ProviderStorage,
		Series, SeriesProvider, Setting, SourceEvent []ent.Hook
	}
	inters struct {
		DownloadQueueItem, EtagCache, ImportEntry, LatestSeries, ProviderStorage,
		Series, SeriesProvider, Setting, SourceEvent []ent.Interceptor
	}
)
